#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Feb 10 23:31:45 2020 by generateDS.py version 2.35.13.
# Python 2.7.16 (default, Dec  3 2019, 07:02:07)  [GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)]
#
# Command line options:
#   ('-o', 'RequestCFD_v33.py')
#   ('-s', 'RequestCFD_v33subs.py')
#
# Command line arguments:
#   RequestCFD_v33_unix.xsd
#
# Command line:
#   /usr/local/bin/generateDS -o "RequestCFD_v33.py" -s "RequestCFD_v33subs.py" RequestCFD_v33_unix.xsd
#
# Current working directory (os.getcwd()):
#   ERsteHlife
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            test_string = "{0:.10g}".format(input_data)
            #return ('%0.10f' % input_data).rstrip('0')
            #return ('%0.10f' % input_data)
            #return ("%0.10f".format(input_data))
            return test_string
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class c_TipoFactor(Enum):
    TASA='Tasa'
    CUOTA='Cuota'
    EXENTO='Exento'


class RequestCFD(GeneratedsSuper):
    """Atributo requerido que indica la versión bajo el que se encuentra
    expresado el documento."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, version='3.3', Comprobante=None, Transaccion=None, TipoComprobante=None, Sucursal=None, Receptor=None, Metadatos=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.Comprobante = Comprobante
        self.Comprobante_nsprefix_ = None
        self.Transaccion = Transaccion
        self.Transaccion_nsprefix_ = None
        self.TipoComprobante = TipoComprobante
        self.TipoComprobante_nsprefix_ = None
        self.Sucursal = Sucursal
        self.Sucursal_nsprefix_ = None
        self.Receptor = Receptor
        self.Receptor_nsprefix_ = None
        self.Metadatos = Metadatos
        self.Metadatos_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestCFD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestCFD.subclass:
            return RequestCFD.subclass(*args_, **kwargs_)
        else:
            return RequestCFD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Comprobante(self):
        return self.Comprobante
    def set_Comprobante(self, Comprobante):
        self.Comprobante = Comprobante
    def get_Transaccion(self):
        return self.Transaccion
    def set_Transaccion(self, Transaccion):
        self.Transaccion = Transaccion
    def get_TipoComprobante(self):
        return self.TipoComprobante
    def set_TipoComprobante(self, TipoComprobante):
        self.TipoComprobante = TipoComprobante
    def get_Sucursal(self):
        return self.Sucursal
    def set_Sucursal(self, Sucursal):
        self.Sucursal = Sucursal
    def get_Receptor(self):
        return self.Receptor
    def set_Receptor(self, Receptor):
        self.Receptor = Receptor
    def get_Metadatos(self):
        return self.Metadatos
    def set_Metadatos(self, Metadatos):
        self.Metadatos = Metadatos
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def hasContent_(self):
        if (
            self.Comprobante is not None or
            self.Transaccion is not None or
            self.TipoComprobante is not None or
            self.Sucursal is not None or
            self.Receptor is not None or
            self.Metadatos is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RequestCFD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestCFD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestCFD')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RequestCFD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RequestCFD'):
        if self.version != "3.3" and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RequestCFD', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comprobante is not None:
            namespaceprefix_ = self.Comprobante_nsprefix_ + ':' if (UseCapturedNS_ and self.Comprobante_nsprefix_) else ''
            self.Comprobante.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comprobante', pretty_print=pretty_print)
        if self.Transaccion is not None:
            namespaceprefix_ = self.Transaccion_nsprefix_ + ':' if (UseCapturedNS_ and self.Transaccion_nsprefix_) else ''
            self.Transaccion.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Transaccion', pretty_print=pretty_print)
        if self.TipoComprobante is not None:
            namespaceprefix_ = self.TipoComprobante_nsprefix_ + ':' if (UseCapturedNS_ and self.TipoComprobante_nsprefix_) else ''
            self.TipoComprobante.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TipoComprobante', pretty_print=pretty_print)
        if self.Sucursal is not None:
            namespaceprefix_ = self.Sucursal_nsprefix_ + ':' if (UseCapturedNS_ and self.Sucursal_nsprefix_) else ''
            self.Sucursal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Sucursal', pretty_print=pretty_print)
        if self.Receptor is not None:
            namespaceprefix_ = self.Receptor_nsprefix_ + ':' if (UseCapturedNS_ and self.Receptor_nsprefix_) else ''
            self.Receptor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Receptor', pretty_print=pretty_print)
        if self.Metadatos is not None:
            namespaceprefix_ = self.Metadatos_nsprefix_ + ':' if (UseCapturedNS_ and self.Metadatos_nsprefix_) else ''
            self.Metadatos.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Metadatos', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Comprobante':
            obj_ = ComprobanteType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comprobante = obj_
            obj_.original_tagname_ = 'Comprobante'
        elif nodeName_ == 'Transaccion':
            obj_ = TransaccionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Transaccion = obj_
            obj_.original_tagname_ = 'Transaccion'
        elif nodeName_ == 'TipoComprobante':
            obj_ = TipoComprobanteType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TipoComprobante = obj_
            obj_.original_tagname_ = 'TipoComprobante'
        elif nodeName_ == 'Sucursal':
            obj_ = SucursalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Sucursal = obj_
            obj_.original_tagname_ = 'Sucursal'
        elif nodeName_ == 'Receptor':
            obj_ = ReceptorType7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Receptor = obj_
            obj_.original_tagname_ = 'Receptor'
        elif nodeName_ == 'Metadatos':
            obj_ = MetadatosType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Metadatos = obj_
            obj_.original_tagname_ = 'Metadatos'
# end class RequestCFD


class ComprobanteType(GeneratedsSuper):
    """Estándar de Comprobante Fiscal Digital por Internet.Atributo requerido
    con valor prefijado a 3.3 que indica la versión del estándar bajo el
    que se encuentra expresado el comprobante.Atributo opcional para
    precisar la serie para control interno del contribuyente. Este atributo
    acepta una cadena de caracteres.Atributo opcional para control interno
    del contribuyente que expresa el folio del comprobante, acepta una
    cadena de caracteres.Atributo opcional (requerido en el CFDI) para la
    expresión de la fecha y hora de expedición del Comprobante Fiscal
    Digital por Internet. Se expresa en la forma AAAA-MM-DDThh:mm:ss y debe
    corresponder con la hora local donde se expide el comprobante.Atributo
    condicional para expresar la clave de la forma de pago de los bienes o
    servicios amparados por el comprobante. Si no se conoce la forma de
    pago este atributo se debe omitir.Atributo opcional (requerido en el
    CFDI) para expresar el número de serie del certificado de sello digital
    que ampara al comprobante, de acuerdo con el acuse correspondiente a 20
    posiciones otorgado por el sistema del SAT.Atributo condicional para
    expresar las condiciones comerciales aplicables para el pago del
    comprobante fiscal digital por Internet. Este atributo puede ser
    condicionado mediante atributos o complementos.Atributo requerido para
    representar la suma de los importes de los conceptos antes de
    descuentos e impuesto. No se permiten valores negativos.Atributo
    condicional para representar el importe total de los descuentos
    aplicables antes de impuestos. No se permiten valores negativos. Se
    debe registrar cuando existan conceptos con descuento.Atributo
    requerido para identificar la clave de la moneda utilizada para
    expresar los montos, cuando se usa moneda nacional se registra MXN.
    Conforme con la especificación ISO 4217.Atributo condicional para
    representar el tipo de cambio conforme con la moneda usada. Es
    requerido cuando la clave de moneda es distinta de MXN y de XXX. El
    valor debe reflejar el número de pesos mexicanos que equivalen a una
    unidad de la divisa señalada en el atributo moneda. Si el valor está
    fuera del porcentaje aplicable a la moneda tomado del catálogo
    c_Moneda, el emisor debe obtener del PAC que vaya a timbrar el CFDI, de
    manera no automática, una clave de confirmación para ratificar que el
    valor es correcto e integrar dicha clave en el atributo
    Confirmacion.Atributo requerido para representar la suma del subtotal,
    menos los descuentos aplicables, más las contribuciones recibidas
    (impuestos trasladados - federales o locales, derechos, productos,
    aprovechamientos, aportaciones de seguridad social, contribuciones de
    mejoras) menos los impuestos retenidos. Si el valor es superior al
    límite que establezca el SAT en la Resolución Miscelánea Fiscal
    vigente, el emisor debe obtener del PAC que vaya a timbrar el CFDI, de
    manera no automática, una clave de confirmación para ratificar que el
    valor es correcto e integrar dicha clave en el atributo Confirmacion.
    No se permiten valores negativos.Atributo requerido para expresar la
    clave del efecto del comprobante fiscal para el contribuyente
    emisor.Atributo condicional para precisar la clave del método de pago
    que aplica para este comprobante fiscal digital por Internet, conforme
    al Artículo 29-A fracción VII incisos a y b del CFF.Atributo opcional
    (requerido en el CFDI) para incorporar el código postal del lugar de
    expedición del comprobante (domicilio de la matriz o de la
    sucursal).Atributo opcional para indicar que en caso de un comprobante
    con importes grandes, con un tipo de cambio fuera del rango establecido
    o con ambos casos. El PAC solicite al SAT una clave de confirmación
    para expedir el comprobante, por default el PAC sí solicitará dicha
    confirmación, en caso de establecerse que no, el PAC rechazará la
    petición."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Version='3.3', Serie=None, Folio=None, Fecha=None, FormaPago=None, NoCertificado=None, CondicionesDePago=None, SubTotal=None, Descuento=None, Moneda=None, TipoCambio=None, Total=None, TipoDeComprobante=None, MetodoPago=None, LugarExpedicion=None, permitirConfirmacion=True, CfdiRelacionados=None, Emisor=None, Receptor=None, Conceptos=None, Impuestos=None, Complemento=None, Addenda=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Version = _cast(None, Version)
        self.Version_nsprefix_ = None
        self.Serie = _cast(None, Serie)
        self.Serie_nsprefix_ = None
        self.Folio = _cast(None, Folio)
        self.Folio_nsprefix_ = None
        self.Fecha = _cast(None, Fecha)
        self.Fecha_nsprefix_ = None
        self.FormaPago = _cast(None, FormaPago)
        self.FormaPago_nsprefix_ = None
        self.NoCertificado = _cast(None, NoCertificado)
        self.NoCertificado_nsprefix_ = None
        self.CondicionesDePago = _cast(None, CondicionesDePago)
        self.CondicionesDePago_nsprefix_ = None
        self.SubTotal = _cast(float, SubTotal)
        self.SubTotal_nsprefix_ = None
        self.Descuento = _cast(float, Descuento)
        self.Descuento_nsprefix_ = None
        self.Moneda = _cast(None, Moneda)
        self.Moneda_nsprefix_ = None
        self.TipoCambio = _cast(float, TipoCambio)
        self.TipoCambio_nsprefix_ = None
        self.Total = _cast(float, Total)
        self.Total_nsprefix_ = None
        self.TipoDeComprobante = _cast(None, TipoDeComprobante)
        self.TipoDeComprobante_nsprefix_ = None
        self.MetodoPago = _cast(None, MetodoPago)
        self.MetodoPago_nsprefix_ = None
        self.LugarExpedicion = _cast(None, LugarExpedicion)
        self.LugarExpedicion_nsprefix_ = None
        self.permitirConfirmacion = _cast(bool, permitirConfirmacion)
        self.permitirConfirmacion_nsprefix_ = None
        self.CfdiRelacionados = CfdiRelacionados
        self.CfdiRelacionados_nsprefix_ = None
        self.Emisor = Emisor
        self.Emisor_nsprefix_ = None
        self.Receptor = Receptor
        self.Receptor_nsprefix_ = None
        self.Conceptos = Conceptos
        self.Conceptos_nsprefix_ = None
        self.Impuestos = Impuestos
        self.Impuestos_nsprefix_ = None
        if Complemento is None:
            self.Complemento = []
        else:
            self.Complemento = Complemento
        self.Complemento_nsprefix_ = None
        self.Addenda = Addenda
        self.Addenda_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComprobanteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComprobanteType.subclass:
            return ComprobanteType.subclass(*args_, **kwargs_)
        else:
            return ComprobanteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CfdiRelacionados(self):
        return self.CfdiRelacionados
    def set_CfdiRelacionados(self, CfdiRelacionados):
        self.CfdiRelacionados = CfdiRelacionados
    def get_Emisor(self):
        return self.Emisor
    def set_Emisor(self, Emisor):
        self.Emisor = Emisor
    def get_Receptor(self):
        return self.Receptor
    def set_Receptor(self, Receptor):
        self.Receptor = Receptor
    def get_Conceptos(self):
        return self.Conceptos
    def set_Conceptos(self, Conceptos):
        self.Conceptos = Conceptos
    def get_Impuestos(self):
        return self.Impuestos
    def set_Impuestos(self, Impuestos):
        self.Impuestos = Impuestos
    def get_Complemento(self):
        return self.Complemento
    def set_Complemento(self, Complemento):
        self.Complemento = Complemento
    def add_Complemento(self, value):
        self.Complemento.append(value)
    def insert_Complemento_at(self, index, value):
        self.Complemento.insert(index, value)
    def replace_Complemento_at(self, index, value):
        self.Complemento[index] = value
    def get_Addenda(self):
        return self.Addenda
    def set_Addenda(self, Addenda):
        self.Addenda = Addenda
    def get_Version(self):
        return self.Version
    def set_Version(self, Version):
        self.Version = Version
    def get_Serie(self):
        return self.Serie
    def set_Serie(self, Serie):
        self.Serie = Serie
    def get_Folio(self):
        return self.Folio
    def set_Folio(self, Folio):
        self.Folio = Folio
    def get_Fecha(self):
        return self.Fecha
    def set_Fecha(self, Fecha):
        self.Fecha = Fecha
    def get_FormaPago(self):
        return self.FormaPago
    def set_FormaPago(self, FormaPago):
        self.FormaPago = FormaPago
    def get_NoCertificado(self):
        return self.NoCertificado
    def set_NoCertificado(self, NoCertificado):
        self.NoCertificado = NoCertificado
    def get_CondicionesDePago(self):
        return self.CondicionesDePago
    def set_CondicionesDePago(self, CondicionesDePago):
        self.CondicionesDePago = CondicionesDePago
    def get_SubTotal(self):
        return self.SubTotal
    def set_SubTotal(self, SubTotal):
        self.SubTotal = SubTotal
    def get_Descuento(self):
        return self.Descuento
    def set_Descuento(self, Descuento):
        self.Descuento = Descuento
    def get_Moneda(self):
        return self.Moneda
    def set_Moneda(self, Moneda):
        self.Moneda = Moneda
    def get_TipoCambio(self):
        return self.TipoCambio
    def set_TipoCambio(self, TipoCambio):
        self.TipoCambio = TipoCambio
    def get_Total(self):
        return self.Total
    def set_Total(self, Total):
        self.Total = Total
    def get_TipoDeComprobante(self):
        return self.TipoDeComprobante
    def set_TipoDeComprobante(self, TipoDeComprobante):
        self.TipoDeComprobante = TipoDeComprobante
    def get_MetodoPago(self):
        return self.MetodoPago
    def set_MetodoPago(self, MetodoPago):
        self.MetodoPago = MetodoPago
    def get_LugarExpedicion(self):
        return self.LugarExpedicion
    def set_LugarExpedicion(self, LugarExpedicion):
        self.LugarExpedicion = LugarExpedicion
    def get_permitirConfirmacion(self):
        return self.permitirConfirmacion
    def set_permitirConfirmacion(self, permitirConfirmacion):
        self.permitirConfirmacion = permitirConfirmacion
    def validate_t_FechaH(self, value):
        # Validate type t_FechaH, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, datetime_.datetime):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (datetime_.datetime)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_t_FechaH_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_t_FechaH_patterns_, ))
    validate_t_FechaH_patterns_ = [[u'^((20[1-9][0-9])-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]))$']]
    def validate_c_FormaPago(self, value):
        # Validate type c_FormaPago, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_FormaPago' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_FormaPago' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_FormaPago_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_FormaPago_patterns_, ))
    validate_c_FormaPago_patterns_ = [[u'^([0-9]{2})$']]
    def validate_t_Importe(self, value):
        # Validate type t_Importe, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_Importe' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_t_Importe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_t_Importe_patterns_, ))
    validate_t_Importe_patterns_ = [[u'^([0-9]{1,18}(.[0-9]{1,6})?)$']]
    def validate_c_Moneda(self, value):
        # Validate type c_Moneda, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_Moneda' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_Moneda' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_Moneda_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_Moneda_patterns_, ))
    validate_c_Moneda_patterns_ = [[u'^([A-Z]{3})$']]
    def validate_c_TipoDeComprobante(self, value):
        # Validate type c_TipoDeComprobante, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_TipoDeComprobante' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_TipoDeComprobante' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_TipoDeComprobante_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_TipoDeComprobante_patterns_, ))
    validate_c_TipoDeComprobante_patterns_ = [[u'^([A-Z]{1})$']]
    def validate_c_MetodoPago(self, value):
        # Validate type c_MetodoPago, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_MetodoPago' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_MetodoPago' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_MetodoPago_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_MetodoPago_patterns_, ))
    validate_c_MetodoPago_patterns_ = [[u'^([A-Z]{3})$']]
    def validate_c_CodigoPostal(self, value):
        # Validate type c_CodigoPostal, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_CodigoPostal' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_CodigoPostal' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_CodigoPostal_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_CodigoPostal_patterns_, ))
    validate_c_CodigoPostal_patterns_ = [[u'^([0-9]{5})$']]
    def hasContent_(self):
        if (
            self.CfdiRelacionados is not None or
            self.Emisor is not None or
            self.Receptor is not None or
            self.Conceptos is not None or
            self.Impuestos is not None or
            self.Complemento or
            self.Addenda is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComprobanteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComprobanteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComprobanteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ComprobanteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ComprobanteType'):
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            outfile.write(' Version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Version), input_name='Version')), ))
        if self.Serie is not None and 'Serie' not in already_processed:
            already_processed.add('Serie')
            outfile.write(' Serie=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Serie), input_name='Serie')), ))
        if self.Folio is not None and 'Folio' not in already_processed:
            already_processed.add('Folio')
            outfile.write(' Folio=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Folio), input_name='Folio')), ))
        if self.Fecha is not None and 'Fecha' not in already_processed:
            already_processed.add('Fecha')
            outfile.write(' Fecha=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Fecha), input_name='Fecha')), ))
        if self.FormaPago is not None and 'FormaPago' not in already_processed:
            already_processed.add('FormaPago')
            outfile.write(' FormaPago=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FormaPago), input_name='FormaPago')), ))
        if self.NoCertificado is not None and 'NoCertificado' not in already_processed:
            already_processed.add('NoCertificado')
            outfile.write(' NoCertificado=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NoCertificado), input_name='NoCertificado')), ))
        if self.CondicionesDePago is not None and 'CondicionesDePago' not in already_processed:
            already_processed.add('CondicionesDePago')
            outfile.write(' CondicionesDePago=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CondicionesDePago), input_name='CondicionesDePago')), ))
        if self.SubTotal is not None and 'SubTotal' not in already_processed:
            already_processed.add('SubTotal')
            outfile.write(' SubTotal="%s"' % self.gds_format_decimal(self.SubTotal, input_name='SubTotal'))
        if self.Descuento is not None and 'Descuento' not in already_processed:
            already_processed.add('Descuento')
            outfile.write(' Descuento="%s"' % self.gds_format_decimal(self.Descuento, input_name='Descuento'))
        if self.Moneda is not None and 'Moneda' not in already_processed:
            already_processed.add('Moneda')
            outfile.write(' Moneda=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Moneda), input_name='Moneda')), ))
        if self.TipoCambio is not None and 'TipoCambio' not in already_processed:
            already_processed.add('TipoCambio')
            outfile.write(' TipoCambio="%s"' % self.gds_format_decimal(self.TipoCambio, input_name='TipoCambio'))
        if self.Total is not None and 'Total' not in already_processed:
            already_processed.add('Total')
            outfile.write(' Total="%s"' % self.gds_format_decimal(self.Total, input_name='Total'))
        if self.TipoDeComprobante is not None and 'TipoDeComprobante' not in already_processed:
            already_processed.add('TipoDeComprobante')
            outfile.write(' TipoDeComprobante=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TipoDeComprobante), input_name='TipoDeComprobante')), ))
        if self.MetodoPago is not None and 'MetodoPago' not in already_processed:
            already_processed.add('MetodoPago')
            outfile.write(' MetodoPago=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MetodoPago), input_name='MetodoPago')), ))
        if self.LugarExpedicion is not None and 'LugarExpedicion' not in already_processed:
            already_processed.add('LugarExpedicion')
            outfile.write(' LugarExpedicion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LugarExpedicion), input_name='LugarExpedicion')), ))
        if not self.permitirConfirmacion and 'permitirConfirmacion' not in already_processed:
            already_processed.add('permitirConfirmacion')
            outfile.write(' permitirConfirmacion="%s"' % self.gds_format_boolean(self.permitirConfirmacion, input_name='permitirConfirmacion'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComprobanteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CfdiRelacionados is not None:
            namespaceprefix_ = self.CfdiRelacionados_nsprefix_ + ':' if (UseCapturedNS_ and self.CfdiRelacionados_nsprefix_) else ''
            self.CfdiRelacionados.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CfdiRelacionados', pretty_print=pretty_print)
        if self.Emisor is not None:
            namespaceprefix_ = self.Emisor_nsprefix_ + ':' if (UseCapturedNS_ and self.Emisor_nsprefix_) else ''
            self.Emisor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Emisor', pretty_print=pretty_print)
        if self.Receptor is not None:
            namespaceprefix_ = self.Receptor_nsprefix_ + ':' if (UseCapturedNS_ and self.Receptor_nsprefix_) else ''
            self.Receptor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Receptor', pretty_print=pretty_print)
        if self.Conceptos is not None:
            namespaceprefix_ = self.Conceptos_nsprefix_ + ':' if (UseCapturedNS_ and self.Conceptos_nsprefix_) else ''
            self.Conceptos.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Conceptos', pretty_print=pretty_print)
        if self.Impuestos is not None:
            namespaceprefix_ = self.Impuestos_nsprefix_ + ':' if (UseCapturedNS_ and self.Impuestos_nsprefix_) else ''
            self.Impuestos.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Impuestos', pretty_print=pretty_print)
        for Complemento_ in self.Complemento:
            namespaceprefix_ = self.Complemento_nsprefix_ + ':' if (UseCapturedNS_ and self.Complemento_nsprefix_) else ''
            Complemento_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Complemento', pretty_print=pretty_print)
        if self.Addenda is not None:
            namespaceprefix_ = self.Addenda_nsprefix_ + ':' if (UseCapturedNS_ and self.Addenda_nsprefix_) else ''
            self.Addenda.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Addenda', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Version', node)
        if value is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            self.Version = value
        value = find_attr_value_('Serie', node)
        if value is not None and 'Serie' not in already_processed:
            already_processed.add('Serie')
            self.Serie = value
        value = find_attr_value_('Folio', node)
        if value is not None and 'Folio' not in already_processed:
            already_processed.add('Folio')
            self.Folio = value
        value = find_attr_value_('Fecha', node)
        if value is not None and 'Fecha' not in already_processed:
            already_processed.add('Fecha')
            try:
                self.Fecha = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (Fecha): %s' % exp)
            self.validate_t_FechaH(self.Fecha)    # validate type t_FechaH
        value = find_attr_value_('FormaPago', node)
        if value is not None and 'FormaPago' not in already_processed:
            already_processed.add('FormaPago')
            self.FormaPago = value
            self.validate_c_FormaPago(self.FormaPago)    # validate type c_FormaPago
        value = find_attr_value_('NoCertificado', node)
        if value is not None and 'NoCertificado' not in already_processed:
            already_processed.add('NoCertificado')
            self.NoCertificado = value
        value = find_attr_value_('CondicionesDePago', node)
        if value is not None and 'CondicionesDePago' not in already_processed:
            already_processed.add('CondicionesDePago')
            self.CondicionesDePago = value
        value = find_attr_value_('SubTotal', node)
        if value is not None and 'SubTotal' not in already_processed:
            already_processed.add('SubTotal')
            value = self.gds_parse_decimal(value, node, 'SubTotal')
            self.SubTotal = value
            self.validate_t_Importe(self.SubTotal)    # validate type t_Importe
        value = find_attr_value_('Descuento', node)
        if value is not None and 'Descuento' not in already_processed:
            already_processed.add('Descuento')
            value = self.gds_parse_decimal(value, node, 'Descuento')
            self.Descuento = value
            self.validate_t_Importe(self.Descuento)    # validate type t_Importe
        value = find_attr_value_('Moneda', node)
        if value is not None and 'Moneda' not in already_processed:
            already_processed.add('Moneda')
            self.Moneda = value
            self.validate_c_Moneda(self.Moneda)    # validate type c_Moneda
        value = find_attr_value_('TipoCambio', node)
        if value is not None and 'TipoCambio' not in already_processed:
            already_processed.add('TipoCambio')
            value = self.gds_parse_decimal(value, node, 'TipoCambio')
            self.TipoCambio = value
        value = find_attr_value_('Total', node)
        if value is not None and 'Total' not in already_processed:
            already_processed.add('Total')
            value = self.gds_parse_decimal(value, node, 'Total')
            self.Total = value
            self.validate_t_Importe(self.Total)    # validate type t_Importe
        value = find_attr_value_('TipoDeComprobante', node)
        if value is not None and 'TipoDeComprobante' not in already_processed:
            already_processed.add('TipoDeComprobante')
            self.TipoDeComprobante = value
            self.validate_c_TipoDeComprobante(self.TipoDeComprobante)    # validate type c_TipoDeComprobante
        value = find_attr_value_('MetodoPago', node)
        if value is not None and 'MetodoPago' not in already_processed:
            already_processed.add('MetodoPago')
            self.MetodoPago = value
            self.validate_c_MetodoPago(self.MetodoPago)    # validate type c_MetodoPago
        value = find_attr_value_('LugarExpedicion', node)
        if value is not None and 'LugarExpedicion' not in already_processed:
            already_processed.add('LugarExpedicion')
            self.LugarExpedicion = value
            self.validate_c_CodigoPostal(self.LugarExpedicion)    # validate type c_CodigoPostal
        value = find_attr_value_('permitirConfirmacion', node)
        if value is not None and 'permitirConfirmacion' not in already_processed:
            already_processed.add('permitirConfirmacion')
            if value in ('true', '1'):
                self.permitirConfirmacion = True
            elif value in ('false', '0'):
                self.permitirConfirmacion = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CfdiRelacionados':
            obj_ = CfdiRelacionadosType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CfdiRelacionados = obj_
            obj_.original_tagname_ = 'CfdiRelacionados'
        elif nodeName_ == 'Emisor':
            obj_ = EmisorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Emisor = obj_
            obj_.original_tagname_ = 'Emisor'
        elif nodeName_ == 'Receptor':
            obj_ = ReceptorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Receptor = obj_
            obj_.original_tagname_ = 'Receptor'
        elif nodeName_ == 'Conceptos':
            obj_ = ConceptosType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Conceptos = obj_
            obj_.original_tagname_ = 'Conceptos'
        elif nodeName_ == 'Impuestos':
            obj_ = ImpuestosType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Impuestos = obj_
            obj_.original_tagname_ = 'Impuestos'
        elif nodeName_ == 'Complemento':
            obj_ = ComplementoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Complemento.append(obj_)
            obj_.original_tagname_ = 'Complemento'
        elif nodeName_ == 'Addenda':
            obj_ = AddendaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Addenda = obj_
            obj_.original_tagname_ = 'Addenda'
# end class ComprobanteType


class CfdiRelacionadosType(GeneratedsSuper):
    """Nodo opcional para precisar la información de los comprobantes
    relacionados.Atributo requerido para indicar la clave de la relación
    que existe entre éste que se esta generando y el o los CFDI previos."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TipoRelacion=None, CfdiRelacionado=None, CfdiInternoRelacionado=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TipoRelacion = _cast(None, TipoRelacion)
        self.TipoRelacion_nsprefix_ = None
        if CfdiRelacionado is None:
            self.CfdiRelacionado = []
        else:
            self.CfdiRelacionado = CfdiRelacionado
        self.CfdiRelacionado_nsprefix_ = None
        if CfdiInternoRelacionado is None:
            self.CfdiInternoRelacionado = []
        else:
            self.CfdiInternoRelacionado = CfdiInternoRelacionado
        self.CfdiInternoRelacionado_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CfdiRelacionadosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CfdiRelacionadosType.subclass:
            return CfdiRelacionadosType.subclass(*args_, **kwargs_)
        else:
            return CfdiRelacionadosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CfdiRelacionado(self):
        return self.CfdiRelacionado
    def set_CfdiRelacionado(self, CfdiRelacionado):
        self.CfdiRelacionado = CfdiRelacionado
    def add_CfdiRelacionado(self, value):
        self.CfdiRelacionado.append(value)
    def insert_CfdiRelacionado_at(self, index, value):
        self.CfdiRelacionado.insert(index, value)
    def replace_CfdiRelacionado_at(self, index, value):
        self.CfdiRelacionado[index] = value
    def get_CfdiInternoRelacionado(self):
        return self.CfdiInternoRelacionado
    def set_CfdiInternoRelacionado(self, CfdiInternoRelacionado):
        self.CfdiInternoRelacionado = CfdiInternoRelacionado
    def add_CfdiInternoRelacionado(self, value):
        self.CfdiInternoRelacionado.append(value)
    def insert_CfdiInternoRelacionado_at(self, index, value):
        self.CfdiInternoRelacionado.insert(index, value)
    def replace_CfdiInternoRelacionado_at(self, index, value):
        self.CfdiInternoRelacionado[index] = value
    def get_TipoRelacion(self):
        return self.TipoRelacion
    def set_TipoRelacion(self, TipoRelacion):
        self.TipoRelacion = TipoRelacion
    def validate_c_TipoRelacion(self, value):
        # Validate type c_TipoRelacion, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_TipoRelacion' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_TipoRelacion' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_TipoRelacion_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_TipoRelacion_patterns_, ))
    validate_c_TipoRelacion_patterns_ = [[u'^([0-9]{2})$']]
    def hasContent_(self):
        if (
            self.CfdiRelacionado or
            self.CfdiInternoRelacionado
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CfdiRelacionadosType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CfdiRelacionadosType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CfdiRelacionadosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CfdiRelacionadosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CfdiRelacionadosType'):
        if self.TipoRelacion is not None and 'TipoRelacion' not in already_processed:
            already_processed.add('TipoRelacion')
            outfile.write(' TipoRelacion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TipoRelacion), input_name='TipoRelacion')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CfdiRelacionadosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CfdiRelacionado_ in self.CfdiRelacionado:
            namespaceprefix_ = self.CfdiRelacionado_nsprefix_ + ':' if (UseCapturedNS_ and self.CfdiRelacionado_nsprefix_) else ''
            CfdiRelacionado_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CfdiRelacionado', pretty_print=pretty_print)
        for CfdiInternoRelacionado_ in self.CfdiInternoRelacionado:
            namespaceprefix_ = self.CfdiInternoRelacionado_nsprefix_ + ':' if (UseCapturedNS_ and self.CfdiInternoRelacionado_nsprefix_) else ''
            CfdiInternoRelacionado_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CfdiInternoRelacionado', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TipoRelacion', node)
        if value is not None and 'TipoRelacion' not in already_processed:
            already_processed.add('TipoRelacion')
            self.TipoRelacion = value
            self.validate_c_TipoRelacion(self.TipoRelacion)    # validate type c_TipoRelacion
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CfdiRelacionado':
            obj_ = CfdiRelacionadoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CfdiRelacionado.append(obj_)
            obj_.original_tagname_ = 'CfdiRelacionado'
        elif nodeName_ == 'CfdiInternoRelacionado':
            obj_ = CfdiInternoRelacionadoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CfdiInternoRelacionado.append(obj_)
            obj_.original_tagname_ = 'CfdiInternoRelacionado'
# end class CfdiRelacionadosType


class CfdiRelacionadoType(GeneratedsSuper):
    """Nodo requerido para precisar la información de los comprobantes
    relacionados.Atributo requerido para registrar el folio fiscal (UUID)
    de un CFDI relacionado con el presente comprobante, por ejemplo: Si el
    CFDI relacionado es un comprobante de traslado que sirve para registrar
    el movimiento de la mercancía. Si este comprobante se usa como nota de
    crédito o nota de débito del comprobante relacionado. Si este
    comprobante es una devolución sobre el comprobante relacionado. Si éste
    sustituye a una factura cancelada."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UUID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UUID = _cast(None, UUID)
        self.UUID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CfdiRelacionadoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CfdiRelacionadoType.subclass:
            return CfdiRelacionadoType.subclass(*args_, **kwargs_)
        else:
            return CfdiRelacionadoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CfdiRelacionadoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CfdiRelacionadoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CfdiRelacionadoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CfdiRelacionadoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CfdiRelacionadoType'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CfdiRelacionadoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CfdiRelacionadoType


class CfdiInternoRelacionadoType(GeneratedsSuper):
    """Nodo requerido para precisar la información de los comprobantes internos
    relacionados.Atributo requerido para relacionar con el presente
    comprobante a algún CFDI resguardado por esta instancia del motor por
    medio del id de la transacción en la que fue registrado."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idTransaccion=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.idTransaccion = _cast(None, idTransaccion)
        self.idTransaccion_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CfdiInternoRelacionadoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CfdiInternoRelacionadoType.subclass:
            return CfdiInternoRelacionadoType.subclass(*args_, **kwargs_)
        else:
            return CfdiInternoRelacionadoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_idTransaccion(self):
        return self.idTransaccion
    def set_idTransaccion(self, idTransaccion):
        self.idTransaccion = idTransaccion
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CfdiInternoRelacionadoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CfdiInternoRelacionadoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CfdiInternoRelacionadoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CfdiInternoRelacionadoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CfdiInternoRelacionadoType'):
        if self.idTransaccion is not None and 'idTransaccion' not in already_processed:
            already_processed.add('idTransaccion')
            outfile.write(' idTransaccion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idTransaccion), input_name='idTransaccion')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CfdiInternoRelacionadoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idTransaccion', node)
        if value is not None and 'idTransaccion' not in already_processed:
            already_processed.add('idTransaccion')
            self.idTransaccion = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CfdiInternoRelacionadoType


class EmisorType(GeneratedsSuper):
    """Nodo requerido para expresar la información del contribuyente emisor del
    comprobante.Atributo requerido para registrar la Clave del Registro
    Federal de Contribuyentes correspondiente al contribuyente emisor del
    comprobante.Atributo opcional para registrar el nombre, denominación o
    razón social del contribuyente emisor del comprobante.Atributo opcional
    (requerido en el CFDI) para incorporar la clave del régimen del
    contribuyente emisor al que aplicará el efecto fiscal de este
    comprobante."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Rfc=None, Nombre=None, RegimenFiscal=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Rfc = _cast(None, Rfc)
        self.Rfc_nsprefix_ = None
        self.Nombre = _cast(None, Nombre)
        self.Nombre_nsprefix_ = None
        self.RegimenFiscal = _cast(None, RegimenFiscal)
        self.RegimenFiscal_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmisorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmisorType.subclass:
            return EmisorType.subclass(*args_, **kwargs_)
        else:
            return EmisorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Rfc(self):
        return self.Rfc
    def set_Rfc(self, Rfc):
        self.Rfc = Rfc
    def get_Nombre(self):
        return self.Nombre
    def set_Nombre(self, Nombre):
        self.Nombre = Nombre
    def get_RegimenFiscal(self):
        return self.RegimenFiscal
    def set_RegimenFiscal(self, RegimenFiscal):
        self.RegimenFiscal = RegimenFiscal
    def validate_t_RFC(self, value):
        # Validate type t_RFC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 13:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on t_RFC' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on t_RFC' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_t_RFC_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_t_RFC_patterns_, ))
    validate_t_RFC_patterns_ = [[u'^([A-Z&\xd1]{3,4}[0-9]{2}(0[1-9]|1[012])(0[1-9]|[12][0-9]|3[01])[A-Z0-9]{2}[0-9A])$']]
    def validate_c_RegimenFiscal(self, value):
        # Validate type c_RegimenFiscal, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_RegimenFiscal' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_RegimenFiscal' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_RegimenFiscal_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_RegimenFiscal_patterns_, ))
    validate_c_RegimenFiscal_patterns_ = [[u'^([0-9]{3})$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EmisorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EmisorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EmisorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EmisorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EmisorType'):
        if self.Rfc is not None and 'Rfc' not in already_processed:
            already_processed.add('Rfc')
            outfile.write(' Rfc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Rfc), input_name='Rfc')), ))
        if self.Nombre is not None and 'Nombre' not in already_processed:
            already_processed.add('Nombre')
            outfile.write(' Nombre=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Nombre), input_name='Nombre')), ))
        if self.RegimenFiscal is not None and 'RegimenFiscal' not in already_processed:
            already_processed.add('RegimenFiscal')
            outfile.write(' RegimenFiscal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.RegimenFiscal), input_name='RegimenFiscal')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EmisorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Rfc', node)
        if value is not None and 'Rfc' not in already_processed:
            already_processed.add('Rfc')
            self.Rfc = value
            self.validate_t_RFC(self.Rfc)    # validate type t_RFC
        value = find_attr_value_('Nombre', node)
        if value is not None and 'Nombre' not in already_processed:
            already_processed.add('Nombre')
            self.Nombre = value
        value = find_attr_value_('RegimenFiscal', node)
        if value is not None and 'RegimenFiscal' not in already_processed:
            already_processed.add('RegimenFiscal')
            self.RegimenFiscal = value
            self.validate_c_RegimenFiscal(self.RegimenFiscal)    # validate type c_RegimenFiscal
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EmisorType


class ReceptorType(GeneratedsSuper):
    """Nodo requerido para precisar la información del contribuyente receptor
    del comprobante.Atributo requerido para precisar la Clave del Registro
    Federal de Contribuyentes correspondiente al contribuyente receptor del
    comprobante.Atributo opcional para precisar el nombre, denominación o
    razón social del contribuyente receptor del comprobante.Atributo
    condicional para registrar la clave del país de residencia para efectos
    fiscales del receptor del comprobante, cuando se trate de un
    extranjero, y que es conforme con la especificación ISO 3166-1 alpha-3.
    Es requerido cuando se incluya el complemento de comercio exterior o se
    registre el atributo NumRegIdTrib.Atributo condicional para expresar el
    número de registro de identidad fiscal del receptor cuando sea
    residente en el extranjero. Es requerido cuando se incluya el
    complemento de comercio exterior.Atributo opcional (requerido en el
    CFDI) para expresar la clave del uso que dará a esta factura el
    receptor del CFDI."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Rfc=None, Nombre=None, ResidenciaFiscal=None, NumRegIdTrib=None, UsoCFDI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Rfc = _cast(None, Rfc)
        self.Rfc_nsprefix_ = None
        self.Nombre = _cast(None, Nombre)
        self.Nombre_nsprefix_ = None
        self.ResidenciaFiscal = _cast(None, ResidenciaFiscal)
        self.ResidenciaFiscal_nsprefix_ = None
        self.NumRegIdTrib = _cast(None, NumRegIdTrib)
        self.NumRegIdTrib_nsprefix_ = None
        self.UsoCFDI = _cast(None, UsoCFDI)
        self.UsoCFDI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReceptorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReceptorType.subclass:
            return ReceptorType.subclass(*args_, **kwargs_)
        else:
            return ReceptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Rfc(self):
        return self.Rfc
    def set_Rfc(self, Rfc):
        self.Rfc = Rfc
    def get_Nombre(self):
        return self.Nombre
    def set_Nombre(self, Nombre):
        self.Nombre = Nombre
    def get_ResidenciaFiscal(self):
        return self.ResidenciaFiscal
    def set_ResidenciaFiscal(self, ResidenciaFiscal):
        self.ResidenciaFiscal = ResidenciaFiscal
    def get_NumRegIdTrib(self):
        return self.NumRegIdTrib
    def set_NumRegIdTrib(self, NumRegIdTrib):
        self.NumRegIdTrib = NumRegIdTrib
    def get_UsoCFDI(self):
        return self.UsoCFDI
    def set_UsoCFDI(self, UsoCFDI):
        self.UsoCFDI = UsoCFDI
    def validate_t_RFC(self, value):
        # Validate type t_RFC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 13:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on t_RFC' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 12:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on t_RFC' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_t_RFC_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_t_RFC_patterns_, ))
    validate_t_RFC_patterns_ = [[u'^([A-Z&\xd1]{3,4}[0-9]{2}(0[1-9]|1[012])(0[1-9]|[12][0-9]|3[01])[A-Z0-9]{2}[0-9A])$']]
    def validate_c_Pais(self, value):
        # Validate type c_Pais, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_Pais' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_Pais' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_Pais_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_Pais_patterns_, ))
    validate_c_Pais_patterns_ = [[u'^([A-Z]{3})$']]
    def validate_c_UsoCFDI(self, value):
        # Validate type c_UsoCFDI, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_UsoCFDI' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_UsoCFDI' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_UsoCFDI_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_UsoCFDI_patterns_, ))
    validate_c_UsoCFDI_patterns_ = [[u'^([A-Z][0-9]{2})$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReceptorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReceptorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReceptorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReceptorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReceptorType'):
        if self.Rfc is not None and 'Rfc' not in already_processed:
            already_processed.add('Rfc')
            outfile.write(' Rfc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Rfc), input_name='Rfc')), ))
        if self.Nombre is not None and 'Nombre' not in already_processed:
            already_processed.add('Nombre')
            outfile.write(' Nombre=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Nombre), input_name='Nombre')), ))
        if self.ResidenciaFiscal is not None and 'ResidenciaFiscal' not in already_processed:
            already_processed.add('ResidenciaFiscal')
            outfile.write(' ResidenciaFiscal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ResidenciaFiscal), input_name='ResidenciaFiscal')), ))
        if self.NumRegIdTrib is not None and 'NumRegIdTrib' not in already_processed:
            already_processed.add('NumRegIdTrib')
            outfile.write(' NumRegIdTrib=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumRegIdTrib), input_name='NumRegIdTrib')), ))
        if self.UsoCFDI is not None and 'UsoCFDI' not in already_processed:
            already_processed.add('UsoCFDI')
            outfile.write(' UsoCFDI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UsoCFDI), input_name='UsoCFDI')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReceptorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Rfc', node)
        if value is not None and 'Rfc' not in already_processed:
            already_processed.add('Rfc')
            self.Rfc = value
            self.validate_t_RFC(self.Rfc)    # validate type t_RFC
        value = find_attr_value_('Nombre', node)
        if value is not None and 'Nombre' not in already_processed:
            already_processed.add('Nombre')
            self.Nombre = value
        value = find_attr_value_('ResidenciaFiscal', node)
        if value is not None and 'ResidenciaFiscal' not in already_processed:
            already_processed.add('ResidenciaFiscal')
            self.ResidenciaFiscal = value
            self.validate_c_Pais(self.ResidenciaFiscal)    # validate type c_Pais
        value = find_attr_value_('NumRegIdTrib', node)
        if value is not None and 'NumRegIdTrib' not in already_processed:
            already_processed.add('NumRegIdTrib')
            self.NumRegIdTrib = value
        value = find_attr_value_('UsoCFDI', node)
        if value is not None and 'UsoCFDI' not in already_processed:
            already_processed.add('UsoCFDI')
            self.UsoCFDI = value
            self.validate_c_UsoCFDI(self.UsoCFDI)    # validate type c_UsoCFDI
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ReceptorType


class ConceptosType(GeneratedsSuper):
    """Nodo requerido para listar los conceptos cubiertos por el
    comprobante."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Concepto=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Concepto is None:
            self.Concepto = []
        else:
            self.Concepto = Concepto
        self.Concepto_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptosType.subclass:
            return ConceptosType.subclass(*args_, **kwargs_)
        else:
            return ConceptosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Concepto(self):
        return self.Concepto
    def set_Concepto(self, Concepto):
        self.Concepto = Concepto
    def add_Concepto(self, value):
        self.Concepto.append(value)
    def insert_Concepto_at(self, index, value):
        self.Concepto.insert(index, value)
    def replace_Concepto_at(self, index, value):
        self.Concepto[index] = value
    def hasContent_(self):
        if (
            self.Concepto
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConceptosType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConceptosType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConceptosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConceptosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConceptosType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConceptosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Concepto_ in self.Concepto:
            namespaceprefix_ = self.Concepto_nsprefix_ + ':' if (UseCapturedNS_ and self.Concepto_nsprefix_) else ''
            Concepto_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Concepto', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Concepto':
            obj_ = ConceptoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Concepto.append(obj_)
            obj_.original_tagname_ = 'Concepto'
# end class ConceptosType


class ConceptoType(GeneratedsSuper):
    """Nodo requerido para registrar la información detallada de un bien o
    servicio amparado en el comprobante.Atributo requerido para expresar la
    clave del producto o del servicio amparado por el presente concepto. Es
    requerido y deben utilizar las claves del catálogo de productos y
    servicios, cuando los conceptos que registren por sus actividades
    correspondan con dichos conceptos.Atributo opcional para expresar el
    número de parte, identificador del producto o del servicio, la clave de
    producto o servicio, SKU o equivalente, propia de la operación del
    emisor, amparado por el presente concepto. Opcionalmente se puede
    utilizar claves del estándar GTIN.Atributo requerido para precisar la
    cantidad de bienes o servicios del tipo particular definido por el
    presente concepto.Atributo requerido para precisar la clave de unidad
    de medida estandarizada aplicable para la cantidad expresada en el
    concepto. La unidad debe corresponder con la descripción del
    concepto.Atributo opcional para precisar la unidad de medida propia de
    la operación del emisor, aplicable para la cantidad expresada en el
    concepto. La unidad debe corresponder con la descripción del
    concepto.Atributo requerido para precisar la descripción del bien o
    servicio cubierto por el presente concepto.Atributo requerido para
    precisar el valor o precio unitario del bien o servicio cubierto por el
    presente concepto.Atributo requerido para precisar el importe total de
    los bienes o servicios del presente concepto. Debe ser equivalente al
    resultado de multiplicar la cantidad por el valor unitario expresado en
    el concepto. No se permiten valores negativos. Atributo opcional para
    representar el importe de los descuentos aplicables al concepto. No se
    permiten valores negativos."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ClaveProdServ=None, NoIdentificacion=None, Cantidad=None, ClaveUnidad=None, Unidad=None, Descripcion=None, ValorUnitario=None, Importe=None, Descuento=None, Impuestos=None, InformacionAduanera=None, CuentaPredial=None, ComplementoConcepto=None, Parte=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ClaveProdServ = _cast(None, ClaveProdServ)
        self.ClaveProdServ_nsprefix_ = None
        self.NoIdentificacion = _cast(None, NoIdentificacion)
        self.NoIdentificacion_nsprefix_ = None
        self.Cantidad = _cast(float, Cantidad)
        self.Cantidad_nsprefix_ = None
        self.ClaveUnidad = _cast(None, ClaveUnidad)
        self.ClaveUnidad_nsprefix_ = None
        self.Unidad = _cast(None, Unidad)
        self.Unidad_nsprefix_ = None
        self.Descripcion = _cast(None, Descripcion)
        self.Descripcion_nsprefix_ = None
        self.ValorUnitario = _cast(float, ValorUnitario)
        self.ValorUnitario_nsprefix_ = None
        self.Importe = _cast(float, Importe)
        self.Importe_nsprefix_ = None
        self.Descuento = _cast(float, Descuento)
        self.Descuento_nsprefix_ = None
        self.Impuestos = Impuestos
        self.Impuestos_nsprefix_ = None
        if InformacionAduanera is None:
            self.InformacionAduanera = []
        else:
            self.InformacionAduanera = InformacionAduanera
        self.InformacionAduanera_nsprefix_ = None
        self.CuentaPredial = CuentaPredial
        self.CuentaPredial_nsprefix_ = None
        self.ComplementoConcepto = ComplementoConcepto
        self.ComplementoConcepto_nsprefix_ = None
        if Parte is None:
            self.Parte = []
        else:
            self.Parte = Parte
        self.Parte_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptoType.subclass:
            return ConceptoType.subclass(*args_, **kwargs_)
        else:
            return ConceptoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Impuestos(self):
        return self.Impuestos
    def set_Impuestos(self, Impuestos):
        self.Impuestos = Impuestos
    def get_InformacionAduanera(self):
        return self.InformacionAduanera
    def set_InformacionAduanera(self, InformacionAduanera):
        self.InformacionAduanera = InformacionAduanera
    def add_InformacionAduanera(self, value):
        self.InformacionAduanera.append(value)
    def insert_InformacionAduanera_at(self, index, value):
        self.InformacionAduanera.insert(index, value)
    def replace_InformacionAduanera_at(self, index, value):
        self.InformacionAduanera[index] = value
    def get_CuentaPredial(self):
        return self.CuentaPredial
    def set_CuentaPredial(self, CuentaPredial):
        self.CuentaPredial = CuentaPredial
    def get_ComplementoConcepto(self):
        return self.ComplementoConcepto
    def set_ComplementoConcepto(self, ComplementoConcepto):
        self.ComplementoConcepto = ComplementoConcepto
    def get_Parte(self):
        return self.Parte
    def set_Parte(self, Parte):
        self.Parte = Parte
    def add_Parte(self, value):
        self.Parte.append(value)
    def insert_Parte_at(self, index, value):
        self.Parte.insert(index, value)
    def replace_Parte_at(self, index, value):
        self.Parte[index] = value
    def get_ClaveProdServ(self):
        return self.ClaveProdServ
    def set_ClaveProdServ(self, ClaveProdServ):
        self.ClaveProdServ = ClaveProdServ
    def get_NoIdentificacion(self):
        return self.NoIdentificacion
    def set_NoIdentificacion(self, NoIdentificacion):
        self.NoIdentificacion = NoIdentificacion
    def get_Cantidad(self):
        return self.Cantidad
    def set_Cantidad(self, Cantidad):
        self.Cantidad = Cantidad
    def get_ClaveUnidad(self):
        return self.ClaveUnidad
    def set_ClaveUnidad(self, ClaveUnidad):
        self.ClaveUnidad = ClaveUnidad
    def get_Unidad(self):
        return self.Unidad
    def set_Unidad(self, Unidad):
        self.Unidad = Unidad
    def get_Descripcion(self):
        return self.Descripcion
    def set_Descripcion(self, Descripcion):
        self.Descripcion = Descripcion
    def get_ValorUnitario(self):
        return self.ValorUnitario
    def set_ValorUnitario(self, ValorUnitario):
        self.ValorUnitario = ValorUnitario
    def get_Importe(self):
        return self.Importe
    def set_Importe(self, Importe):
        self.Importe = Importe
    def get_Descuento(self):
        return self.Descuento
    def set_Descuento(self, Descuento):
        self.Descuento = Descuento
    def validate_c_ClaveProdServ(self, value):
        # Validate type c_ClaveProdServ, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_ClaveProdServ' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_ClaveProdServ' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_ClaveProdServ_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_ClaveProdServ_patterns_, ))
    validate_c_ClaveProdServ_patterns_ = [[u'^([0-9]{8})$']]
    def validate_c_ClaveUnidad(self, value):
        # Validate type c_ClaveUnidad, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_ClaveUnidad' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_ClaveUnidad' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_ClaveUnidad_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_ClaveUnidad_patterns_, ))
    validate_c_ClaveUnidad_patterns_ = [[u'^([A-Z,0-9]{2,3})$']]
    def validate_t_Importe(self, value):
        # Validate type t_Importe, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_Importe' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_t_Importe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_t_Importe_patterns_, ))
    validate_t_Importe_patterns_ = [[u'^([0-9]{1,18}(.[0-9]{1,6})?)$']]
    def hasContent_(self):
        if (
            self.Impuestos is not None or
            self.InformacionAduanera or
            self.CuentaPredial is not None or
            self.ComplementoConcepto is not None or
            self.Parte
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConceptoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConceptoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConceptoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConceptoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConceptoType'):
        if self.ClaveProdServ is not None and 'ClaveProdServ' not in already_processed:
            already_processed.add('ClaveProdServ')
            outfile.write(' ClaveProdServ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ClaveProdServ), input_name='ClaveProdServ')), ))
        if self.NoIdentificacion is not None and 'NoIdentificacion' not in already_processed:
            already_processed.add('NoIdentificacion')
            outfile.write(' NoIdentificacion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NoIdentificacion), input_name='NoIdentificacion')), ))
        if self.Cantidad is not None and 'Cantidad' not in already_processed:
            already_processed.add('Cantidad')
            outfile.write(' Cantidad="%s"' % self.gds_format_decimal(self.Cantidad, input_name='Cantidad'))
        if self.ClaveUnidad is not None and 'ClaveUnidad' not in already_processed:
            already_processed.add('ClaveUnidad')
            outfile.write(' ClaveUnidad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ClaveUnidad), input_name='ClaveUnidad')), ))
        if self.Unidad is not None and 'Unidad' not in already_processed:
            already_processed.add('Unidad')
            outfile.write(' Unidad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Unidad), input_name='Unidad')), ))
        if self.Descripcion is not None and 'Descripcion' not in already_processed:
            already_processed.add('Descripcion')
            outfile.write(' Descripcion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Descripcion), input_name='Descripcion')), ))
        if self.ValorUnitario is not None and 'ValorUnitario' not in already_processed:
            already_processed.add('ValorUnitario')
            outfile.write(' ValorUnitario="%s"' % self.gds_format_decimal(self.ValorUnitario, input_name='ValorUnitario'))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe="%s"' % self.gds_format_decimal(self.Importe, input_name='Importe'))
        if self.Descuento is not None and 'Descuento' not in already_processed:
            already_processed.add('Descuento')
            outfile.write(' Descuento="%s"' % self.gds_format_decimal(self.Descuento, input_name='Descuento'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConceptoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Impuestos is not None:
            namespaceprefix_ = self.Impuestos_nsprefix_ + ':' if (UseCapturedNS_ and self.Impuestos_nsprefix_) else ''
            self.Impuestos.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Impuestos', pretty_print=pretty_print)
        for InformacionAduanera_ in self.InformacionAduanera:
            namespaceprefix_ = self.InformacionAduanera_nsprefix_ + ':' if (UseCapturedNS_ and self.InformacionAduanera_nsprefix_) else ''
            InformacionAduanera_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InformacionAduanera', pretty_print=pretty_print)
        if self.CuentaPredial is not None:
            namespaceprefix_ = self.CuentaPredial_nsprefix_ + ':' if (UseCapturedNS_ and self.CuentaPredial_nsprefix_) else ''
            self.CuentaPredial.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CuentaPredial', pretty_print=pretty_print)
        if self.ComplementoConcepto is not None:
            namespaceprefix_ = self.ComplementoConcepto_nsprefix_ + ':' if (UseCapturedNS_ and self.ComplementoConcepto_nsprefix_) else ''
            self.ComplementoConcepto.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ComplementoConcepto', pretty_print=pretty_print)
        for Parte_ in self.Parte:
            namespaceprefix_ = self.Parte_nsprefix_ + ':' if (UseCapturedNS_ and self.Parte_nsprefix_) else ''
            Parte_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Parte', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ClaveProdServ', node)
        if value is not None and 'ClaveProdServ' not in already_processed:
            already_processed.add('ClaveProdServ')
            self.ClaveProdServ = value
            self.validate_c_ClaveProdServ(self.ClaveProdServ)    # validate type c_ClaveProdServ
        value = find_attr_value_('NoIdentificacion', node)
        if value is not None and 'NoIdentificacion' not in already_processed:
            already_processed.add('NoIdentificacion')
            self.NoIdentificacion = value
        value = find_attr_value_('Cantidad', node)
        if value is not None and 'Cantidad' not in already_processed:
            already_processed.add('Cantidad')
            value = self.gds_parse_decimal(value, node, 'Cantidad')
            self.Cantidad = value
        value = find_attr_value_('ClaveUnidad', node)
        if value is not None and 'ClaveUnidad' not in already_processed:
            already_processed.add('ClaveUnidad')
            self.ClaveUnidad = value
            self.validate_c_ClaveUnidad(self.ClaveUnidad)    # validate type c_ClaveUnidad
        value = find_attr_value_('Unidad', node)
        if value is not None and 'Unidad' not in already_processed:
            already_processed.add('Unidad')
            self.Unidad = value
        value = find_attr_value_('Descripcion', node)
        if value is not None and 'Descripcion' not in already_processed:
            already_processed.add('Descripcion')
            self.Descripcion = value
        value = find_attr_value_('ValorUnitario', node)
        if value is not None and 'ValorUnitario' not in already_processed:
            already_processed.add('ValorUnitario')
            value = self.gds_parse_decimal(value, node, 'ValorUnitario')
            self.ValorUnitario = value
            self.validate_t_Importe(self.ValorUnitario)    # validate type t_Importe
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            value = self.gds_parse_decimal(value, node, 'Importe')
            self.Importe = value
            self.validate_t_Importe(self.Importe)    # validate type t_Importe
        value = find_attr_value_('Descuento', node)
        if value is not None and 'Descuento' not in already_processed:
            already_processed.add('Descuento')
            value = self.gds_parse_decimal(value, node, 'Descuento')
            self.Descuento = value
            self.validate_t_Importe(self.Descuento)    # validate type t_Importe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Impuestos':
            obj_ = ImpuestosType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Impuestos = obj_
            obj_.original_tagname_ = 'Impuestos'
        elif nodeName_ == 'InformacionAduanera':
            obj_ = InformacionAduaneraType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InformacionAduanera.append(obj_)
            obj_.original_tagname_ = 'InformacionAduanera'
        elif nodeName_ == 'CuentaPredial':
            obj_ = CuentaPredialType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CuentaPredial = obj_
            obj_.original_tagname_ = 'CuentaPredial'
        elif nodeName_ == 'ComplementoConcepto':
            obj_ = ComplementoConceptoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ComplementoConcepto = obj_
            obj_.original_tagname_ = 'ComplementoConcepto'
        elif nodeName_ == 'Parte':
            obj_ = ParteType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Parte.append(obj_)
            obj_.original_tagname_ = 'Parte'
# end class ConceptoType


class ImpuestosType(GeneratedsSuper):
    """Nodo opcional para capturar los impuestos aplicables al presente
    concepto. Cuando un concepto no registra un impuesto, implica que no es
    objeto del mismo."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Traslados=None, Retenciones=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Traslados = Traslados
        self.Traslados_nsprefix_ = None
        self.Retenciones = Retenciones
        self.Retenciones_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImpuestosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImpuestosType.subclass:
            return ImpuestosType.subclass(*args_, **kwargs_)
        else:
            return ImpuestosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Traslados(self):
        return self.Traslados
    def set_Traslados(self, Traslados):
        self.Traslados = Traslados
    def get_Retenciones(self):
        return self.Retenciones
    def set_Retenciones(self, Retenciones):
        self.Retenciones = Retenciones
    def hasContent_(self):
        if (
            self.Traslados is not None or
            self.Retenciones is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImpuestosType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImpuestosType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImpuestosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ImpuestosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ImpuestosType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImpuestosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Traslados is not None:
            namespaceprefix_ = self.Traslados_nsprefix_ + ':' if (UseCapturedNS_ and self.Traslados_nsprefix_) else ''
            self.Traslados.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Traslados', pretty_print=pretty_print)
        if self.Retenciones is not None:
            namespaceprefix_ = self.Retenciones_nsprefix_ + ':' if (UseCapturedNS_ and self.Retenciones_nsprefix_) else ''
            self.Retenciones.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Retenciones', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Traslados':
            obj_ = TrasladosType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Traslados = obj_
            obj_.original_tagname_ = 'Traslados'
        elif nodeName_ == 'Retenciones':
            obj_ = RetencionesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Retenciones = obj_
            obj_.original_tagname_ = 'Retenciones'
# end class ImpuestosType


class TrasladosType(GeneratedsSuper):
    """Nodo opcional para asentar los impuestos trasladados aplicables al
    presente concepto."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Traslado=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Traslado is None:
            self.Traslado = []
        else:
            self.Traslado = Traslado
        self.Traslado_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrasladosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrasladosType.subclass:
            return TrasladosType.subclass(*args_, **kwargs_)
        else:
            return TrasladosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Traslado(self):
        return self.Traslado
    def set_Traslado(self, Traslado):
        self.Traslado = Traslado
    def add_Traslado(self, value):
        self.Traslado.append(value)
    def insert_Traslado_at(self, index, value):
        self.Traslado.insert(index, value)
    def replace_Traslado_at(self, index, value):
        self.Traslado[index] = value
    def hasContent_(self):
        if (
            self.Traslado
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TrasladosType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrasladosType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrasladosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TrasladosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TrasladosType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TrasladosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Traslado_ in self.Traslado:
            namespaceprefix_ = self.Traslado_nsprefix_ + ':' if (UseCapturedNS_ and self.Traslado_nsprefix_) else ''
            Traslado_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Traslado', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Traslado':
            obj_ = TrasladoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Traslado.append(obj_)
            obj_.original_tagname_ = 'Traslado'
# end class TrasladosType


class TrasladoType(GeneratedsSuper):
    """Nodo requerido para asentar la información detallada de un traslado de
    impuestos aplicable al presente concepto.Atributo requerido para
    señalar la base para el cálculo del impuesto, la determinación de la
    base se realiza de acuerdo con las disposiciones fiscales vigentes. No
    se permiten valores negativos.Atributo requerido para señalar la clave
    del tipo de impuesto trasladado aplicable al concepto.Atributo
    requerido para señalar la clave del tipo de factor que se aplica a la
    base del impuesto.Atributo condicional para señalar el valor de la tasa
    o cuota del impuesto que se traslada para el presente concepto. Es
    requerido cuando el atributo TipoFactor tenga una clave que corresponda
    a Tasa o Cuota.Atributo condicional para señalar el importe del
    impuesto trasladado que aplica al concepto. No se permiten valores
    negativos. Es requerido cuando TipoFactor sea Tasa o Cuota"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Base=None, Impuesto=None, TipoFactor=None, TasaOCuota=None, Importe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Base = _cast(float, Base)
        self.Base_nsprefix_ = None
        self.Impuesto = _cast(None, Impuesto)
        self.Impuesto_nsprefix_ = None
        self.TipoFactor = _cast(None, TipoFactor)
        self.TipoFactor_nsprefix_ = None
        self.TasaOCuota = _cast(float, TasaOCuota)
        self.TasaOCuota_nsprefix_ = None
        self.Importe = _cast(float, Importe)
        self.Importe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrasladoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrasladoType.subclass:
            return TrasladoType.subclass(*args_, **kwargs_)
        else:
            return TrasladoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Base(self):
        return self.Base
    def set_Base(self, Base):
        self.Base = Base
    def get_Impuesto(self):
        return self.Impuesto
    def set_Impuesto(self, Impuesto):
        self.Impuesto = Impuesto
    def get_TipoFactor(self):
        return self.TipoFactor
    def set_TipoFactor(self, TipoFactor):
        self.TipoFactor = TipoFactor
    def get_TasaOCuota(self):
        return self.TasaOCuota
    def set_TasaOCuota(self, TasaOCuota):
        self.TasaOCuota = TasaOCuota
    def get_Importe(self):
        return self.Importe
    def set_Importe(self, Importe):
        self.Importe = Importe
    def validate_t_Importe(self, value):
        # Validate type t_Importe, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_Importe' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_t_Importe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_t_Importe_patterns_, ))
    validate_t_Importe_patterns_ = [[u'^([0-9]{1,18}(.[0-9]{1,6})?)$']]
    def validate_c_Impuesto(self, value):
        # Validate type c_Impuesto, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_Impuesto' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_Impuesto' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_Impuesto_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_Impuesto_patterns_, ))
    validate_c_Impuesto_patterns_ = [[u'^([0-9]{3})$']]
    def validate_c_TipoFactor(self, value):
        # Validate type c_TipoFactor, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Tasa', 'Cuota', 'Exento']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on c_TipoFactor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_c_TasaOCuota(self, value):
        # Validate type c_TasaOCuota, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on c_TasaOCuota' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 7:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on c_TasaOCuota' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TrasladoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrasladoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrasladoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TrasladoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TrasladoType'):
        if self.Base is not None and 'Base' not in already_processed:
            already_processed.add('Base')
            outfile.write(' Base="%s"' % self.gds_format_decimal(self.Base, input_name='Base'))
        if self.Impuesto is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            outfile.write(' Impuesto=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Impuesto), input_name='Impuesto')), ))
        if self.TipoFactor is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            outfile.write(' TipoFactor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TipoFactor), input_name='TipoFactor')), ))
        if self.TasaOCuota is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            outfile.write(' TasaOCuota="%s"' % self.gds_format_decimal(self.TasaOCuota, input_name='TasaOCuota'))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe="%s"' % self.gds_format_decimal(self.Importe, input_name='Importe'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TrasladoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Base', node)
        if value is not None and 'Base' not in already_processed:
            already_processed.add('Base')
            value = self.gds_parse_decimal(value, node, 'Base')
            self.Base = value
            self.validate_t_Importe(self.Base)    # validate type t_Importe
        value = find_attr_value_('Impuesto', node)
        if value is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            self.Impuesto = value
            self.validate_c_Impuesto(self.Impuesto)    # validate type c_Impuesto
        value = find_attr_value_('TipoFactor', node)
        if value is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            self.TipoFactor = value
            self.validate_c_TipoFactor(self.TipoFactor)    # validate type c_TipoFactor
        value = find_attr_value_('TasaOCuota', node)
        if value is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            value = self.gds_parse_decimal(value, node, 'TasaOCuota')
            self.TasaOCuota = value
            self.validate_c_TasaOCuota(self.TasaOCuota)    # validate type c_TasaOCuota
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            value = self.gds_parse_decimal(value, node, 'Importe')
            self.Importe = value
            self.validate_t_Importe(self.Importe)    # validate type t_Importe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TrasladoType


class RetencionesType(GeneratedsSuper):
    """Nodo opcional para asentar los impuestos retenidos aplicables al
    presente concepto."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Retencion=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Retencion is None:
            self.Retencion = []
        else:
            self.Retencion = Retencion
        self.Retencion_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetencionesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetencionesType.subclass:
            return RetencionesType.subclass(*args_, **kwargs_)
        else:
            return RetencionesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Retencion(self):
        return self.Retencion
    def set_Retencion(self, Retencion):
        self.Retencion = Retencion
    def add_Retencion(self, value):
        self.Retencion.append(value)
    def insert_Retencion_at(self, index, value):
        self.Retencion.insert(index, value)
    def replace_Retencion_at(self, index, value):
        self.Retencion[index] = value
    def hasContent_(self):
        if (
            self.Retencion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RetencionesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RetencionesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RetencionesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RetencionesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RetencionesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RetencionesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Retencion_ in self.Retencion:
            namespaceprefix_ = self.Retencion_nsprefix_ + ':' if (UseCapturedNS_ and self.Retencion_nsprefix_) else ''
            Retencion_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Retencion', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Retencion':
            obj_ = RetencionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Retencion.append(obj_)
            obj_.original_tagname_ = 'Retencion'
# end class RetencionesType


class RetencionType(GeneratedsSuper):
    """Nodo requerido para asentar la información detallada de una retención de
    impuestos aplicable al presente concepto.Atributo requerido para
    señalar la base para el cálculo de la retención, la determinación de la
    base se realiza de acuerdo con las disposiciones fiscales vigentes. No
    se permiten valores negativos.Atributo requerido para señalar la clave
    del tipo de impuesto retenido aplicable al concepto.Atributo requerido
    para señalar la clave del tipo de factor que se aplica a la base del
    impuesto.Atributo requerido para señalar la tasa o cuota del impuesto
    que se retiene para el presente concepto.Atributo requerido para
    señalar el importe del impuesto retenido que aplica al concepto. No se
    permiten valores negativos."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Base=None, Impuesto=None, TipoFactor=None, TasaOCuota=None, Importe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Base = _cast(float, Base)
        self.Base_nsprefix_ = None
        self.Impuesto = _cast(None, Impuesto)
        self.Impuesto_nsprefix_ = None
        self.TipoFactor = _cast(None, TipoFactor)
        self.TipoFactor_nsprefix_ = None
        self.TasaOCuota = _cast(float, TasaOCuota)
        self.TasaOCuota_nsprefix_ = None
        self.Importe = _cast(float, Importe)
        self.Importe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetencionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetencionType.subclass:
            return RetencionType.subclass(*args_, **kwargs_)
        else:
            return RetencionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Base(self):
        return self.Base
    def set_Base(self, Base):
        self.Base = Base
    def get_Impuesto(self):
        return self.Impuesto
    def set_Impuesto(self, Impuesto):
        self.Impuesto = Impuesto
    def get_TipoFactor(self):
        return self.TipoFactor
    def set_TipoFactor(self, TipoFactor):
        self.TipoFactor = TipoFactor
    def get_TasaOCuota(self):
        return self.TasaOCuota
    def set_TasaOCuota(self, TasaOCuota):
        self.TasaOCuota = TasaOCuota
    def get_Importe(self):
        return self.Importe
    def set_Importe(self, Importe):
        self.Importe = Importe
    def validate_t_Importe(self, value):
        # Validate type t_Importe, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_Importe' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_t_Importe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_t_Importe_patterns_, ))
    validate_t_Importe_patterns_ = [[u'^([0-9]{1,18}(.[0-9]{1,6})?)$']]
    def validate_c_Impuesto(self, value):
        # Validate type c_Impuesto, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_Impuesto' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_Impuesto' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_Impuesto_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_Impuesto_patterns_, ))
    validate_c_Impuesto_patterns_ = [[u'^([0-9]{3})$']]
    def validate_c_TipoFactor(self, value):
        # Validate type c_TipoFactor, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Tasa', 'Cuota', 'Exento']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on c_TipoFactor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RetencionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RetencionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RetencionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RetencionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RetencionType'):
        if self.Base is not None and 'Base' not in already_processed:
            already_processed.add('Base')
            outfile.write(' Base="%s"' % self.gds_format_decimal(self.Base, input_name='Base'))
        if self.Impuesto is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            outfile.write(' Impuesto=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Impuesto), input_name='Impuesto')), ))
        if self.TipoFactor is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            outfile.write(' TipoFactor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TipoFactor), input_name='TipoFactor')), ))
        if self.TasaOCuota is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            outfile.write(' TasaOCuota="%s"' % self.gds_format_decimal(self.TasaOCuota, input_name='TasaOCuota'))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe="%s"' % self.gds_format_decimal(self.Importe, input_name='Importe'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RetencionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Base', node)
        if value is not None and 'Base' not in already_processed:
            already_processed.add('Base')
            value = self.gds_parse_decimal(value, node, 'Base')
            self.Base = value
            self.validate_t_Importe(self.Base)    # validate type t_Importe
        value = find_attr_value_('Impuesto', node)
        if value is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            self.Impuesto = value
            self.validate_c_Impuesto(self.Impuesto)    # validate type c_Impuesto
        value = find_attr_value_('TipoFactor', node)
        if value is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            self.TipoFactor = value
            self.validate_c_TipoFactor(self.TipoFactor)    # validate type c_TipoFactor
        value = find_attr_value_('TasaOCuota', node)
        if value is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            value = self.gds_parse_decimal(value, node, 'TasaOCuota')
            self.TasaOCuota = value
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            value = self.gds_parse_decimal(value, node, 'Importe')
            self.Importe = value
            self.validate_t_Importe(self.Importe)    # validate type t_Importe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RetencionType


class InformacionAduaneraType(GeneratedsSuper):
    """Nodo opcional para introducir la información aduanera aplicable cuando
    se trate de ventas de primera mano de mercancías importadas o se trate
    de operaciones de comercio exterior con bienes o servicios.Atributo
    requerido para expresar el número del pedimento que ampara la
    importación del bien que se expresa en el siguiente formato: últimos 2
    dígitos del año de validación seguidos por dos espacios, 2 dígitos de
    la aduana de despacho seguidos por dos espacios, 4 dígitos del número
    de la patente seguidos por dos espacios, 1 dígito que corresponde al
    último dígito del año en curso, salvo que se trate de un pedimento
    consolidado iniciado en el año inmediato anterior o del pedimento
    original de una rectificación, seguido de 6 dígitos de la numeración
    progresiva por aduana."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NumeroPedimento=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NumeroPedimento = _cast(None, NumeroPedimento)
        self.NumeroPedimento_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformacionAduaneraType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformacionAduaneraType.subclass:
            return InformacionAduaneraType.subclass(*args_, **kwargs_)
        else:
            return InformacionAduaneraType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NumeroPedimento(self):
        return self.NumeroPedimento
    def set_NumeroPedimento(self, NumeroPedimento):
        self.NumeroPedimento = NumeroPedimento
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InformacionAduaneraType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InformacionAduaneraType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InformacionAduaneraType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InformacionAduaneraType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InformacionAduaneraType'):
        if self.NumeroPedimento is not None and 'NumeroPedimento' not in already_processed:
            already_processed.add('NumeroPedimento')
            outfile.write(' NumeroPedimento=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumeroPedimento), input_name='NumeroPedimento')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InformacionAduaneraType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NumeroPedimento', node)
        if value is not None and 'NumeroPedimento' not in already_processed:
            already_processed.add('NumeroPedimento')
            self.NumeroPedimento = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class InformacionAduaneraType


class CuentaPredialType(GeneratedsSuper):
    """Nodo opcional para asentar el número de cuenta predial con el que fue
    registrado el inmueble, en el sistema catastral de la entidad
    federativa de que trate, o bien para incorporar los datos de
    identificación del certificado de participación inmobiliaria no
    amortizable.Atributo requerido para precisar el número de la cuenta
    predial del inmueble cubierto por el presente concepto, o bien para
    incorporar los datos de identificación del certificado de participación
    inmobiliaria no amortizable, tratándose de arrendamiento."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Numero=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Numero = _cast(None, Numero)
        self.Numero_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CuentaPredialType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CuentaPredialType.subclass:
            return CuentaPredialType.subclass(*args_, **kwargs_)
        else:
            return CuentaPredialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Numero(self):
        return self.Numero
    def set_Numero(self, Numero):
        self.Numero = Numero
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CuentaPredialType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CuentaPredialType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CuentaPredialType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CuentaPredialType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CuentaPredialType'):
        if self.Numero is not None and 'Numero' not in already_processed:
            already_processed.add('Numero')
            outfile.write(' Numero=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Numero), input_name='Numero')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CuentaPredialType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Numero', node)
        if value is not None and 'Numero' not in already_processed:
            already_processed.add('Numero')
            self.Numero = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CuentaPredialType


class ComplementoConceptoType(GeneratedsSuper):
    """Nodo opcional donde se incluyen los nodos complementarios de extensión
    al concepto definidos por el SAT, de acuerdo con las disposiciones
    particulares para un sector o actividad específica."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComplementoConceptoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComplementoConceptoType.subclass:
            return ComplementoConceptoType.subclass(*args_, **kwargs_)
        else:
            return ComplementoConceptoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComplementoConceptoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComplementoConceptoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComplementoConceptoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ComplementoConceptoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ComplementoConceptoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComplementoConceptoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'ComplementoConceptoType')
        self.add_anytypeobjs_(content_)
# end class ComplementoConceptoType


class ParteType(GeneratedsSuper):
    """Nodo opcional para expresar las partes o componentes que integran la
    totalidad del concepto expresado en el comprobante fiscal digital por
    Internet.Atributo requerido para expresar la clave del producto o del
    servicio amparado por la presente parte. Es requerido y deben utilizar
    las claves del catálogo de productos y servicios, cuando los conceptos
    que registren por sus actividades correspondan con dichos
    conceptos.Atributo opcional para expresar el número de serie, número de
    parte del bien o identificador del producto o del servicio amparado por
    la presente parte. Opcionalmente se puede utilizar claves del estándar
    GTIN.Atributo requerido para precisar la cantidad de bienes o servicios
    del tipo particular definido por la presente parte.Atributo opcional
    para precisar la unidad de medida propia de la operación del emisor,
    aplicable para la cantidad expresada en la parte. La unidad debe
    corresponder con la descripción de la parte. Atributo requerido para
    precisar la descripción del bien o servicio cubierto por la presente
    parte.Atributo opcional para precisar el valor o precio unitario del
    bien o servicio cubierto por la presente parte. No se permiten valores
    negativos.Atributo opcional para precisar el importe total de los
    bienes o servicios de la presente parte. Debe ser equivalente al
    resultado de multiplicar la cantidad por el valor unitario expresado en
    la parte. No se permiten valores negativos."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ClaveProdServ=None, NoIdentificacion=None, Cantidad=None, Unidad=None, Descripcion=None, ValorUnitario=None, Importe=None, InformacionAduanera=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ClaveProdServ = _cast(None, ClaveProdServ)
        self.ClaveProdServ_nsprefix_ = None
        self.NoIdentificacion = _cast(None, NoIdentificacion)
        self.NoIdentificacion_nsprefix_ = None
        self.Cantidad = _cast(float, Cantidad)
        self.Cantidad_nsprefix_ = None
        self.Unidad = _cast(None, Unidad)
        self.Unidad_nsprefix_ = None
        self.Descripcion = _cast(None, Descripcion)
        self.Descripcion_nsprefix_ = None
        self.ValorUnitario = _cast(float, ValorUnitario)
        self.ValorUnitario_nsprefix_ = None
        self.Importe = _cast(float, Importe)
        self.Importe_nsprefix_ = None
        if InformacionAduanera is None:
            self.InformacionAduanera = []
        else:
            self.InformacionAduanera = InformacionAduanera
        self.InformacionAduanera_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParteType.subclass:
            return ParteType.subclass(*args_, **kwargs_)
        else:
            return ParteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_InformacionAduanera(self):
        return self.InformacionAduanera
    def set_InformacionAduanera(self, InformacionAduanera):
        self.InformacionAduanera = InformacionAduanera
    def add_InformacionAduanera(self, value):
        self.InformacionAduanera.append(value)
    def insert_InformacionAduanera_at(self, index, value):
        self.InformacionAduanera.insert(index, value)
    def replace_InformacionAduanera_at(self, index, value):
        self.InformacionAduanera[index] = value
    def get_ClaveProdServ(self):
        return self.ClaveProdServ
    def set_ClaveProdServ(self, ClaveProdServ):
        self.ClaveProdServ = ClaveProdServ
    def get_NoIdentificacion(self):
        return self.NoIdentificacion
    def set_NoIdentificacion(self, NoIdentificacion):
        self.NoIdentificacion = NoIdentificacion
    def get_Cantidad(self):
        return self.Cantidad
    def set_Cantidad(self, Cantidad):
        self.Cantidad = Cantidad
    def get_Unidad(self):
        return self.Unidad
    def set_Unidad(self, Unidad):
        self.Unidad = Unidad
    def get_Descripcion(self):
        return self.Descripcion
    def set_Descripcion(self, Descripcion):
        self.Descripcion = Descripcion
    def get_ValorUnitario(self):
        return self.ValorUnitario
    def set_ValorUnitario(self, ValorUnitario):
        self.ValorUnitario = ValorUnitario
    def get_Importe(self):
        return self.Importe
    def set_Importe(self, Importe):
        self.Importe = Importe
    def validate_c_ClaveProdServ(self, value):
        # Validate type c_ClaveProdServ, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_ClaveProdServ' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_ClaveProdServ' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_ClaveProdServ_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_ClaveProdServ_patterns_, ))
    validate_c_ClaveProdServ_patterns_ = [[u'^([0-9]{8})$']]
    def validate_t_Importe(self, value):
        # Validate type t_Importe, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_Importe' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_t_Importe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_t_Importe_patterns_, ))
    validate_t_Importe_patterns_ = [[u'^([0-9]{1,18}(.[0-9]{1,6})?)$']]
    def hasContent_(self):
        if (
            self.InformacionAduanera
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParteType'):
        if self.ClaveProdServ is not None and 'ClaveProdServ' not in already_processed:
            already_processed.add('ClaveProdServ')
            outfile.write(' ClaveProdServ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ClaveProdServ), input_name='ClaveProdServ')), ))
        if self.NoIdentificacion is not None and 'NoIdentificacion' not in already_processed:
            already_processed.add('NoIdentificacion')
            outfile.write(' NoIdentificacion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NoIdentificacion), input_name='NoIdentificacion')), ))
        if self.Cantidad is not None and 'Cantidad' not in already_processed:
            already_processed.add('Cantidad')
            outfile.write(' Cantidad="%s"' % self.gds_format_decimal(self.Cantidad, input_name='Cantidad'))
        if self.Unidad is not None and 'Unidad' not in already_processed:
            already_processed.add('Unidad')
            outfile.write(' Unidad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Unidad), input_name='Unidad')), ))
        if self.Descripcion is not None and 'Descripcion' not in already_processed:
            already_processed.add('Descripcion')
            outfile.write(' Descripcion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Descripcion), input_name='Descripcion')), ))
        if self.ValorUnitario is not None and 'ValorUnitario' not in already_processed:
            already_processed.add('ValorUnitario')
            outfile.write(' ValorUnitario="%s"' % self.gds_format_decimal(self.ValorUnitario, input_name='ValorUnitario'))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe="%s"' % self.gds_format_decimal(self.Importe, input_name='Importe'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for InformacionAduanera_ in self.InformacionAduanera:
            namespaceprefix_ = self.InformacionAduanera_nsprefix_ + ':' if (UseCapturedNS_ and self.InformacionAduanera_nsprefix_) else ''
            InformacionAduanera_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InformacionAduanera', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ClaveProdServ', node)
        if value is not None and 'ClaveProdServ' not in already_processed:
            already_processed.add('ClaveProdServ')
            self.ClaveProdServ = value
            self.validate_c_ClaveProdServ(self.ClaveProdServ)    # validate type c_ClaveProdServ
        value = find_attr_value_('NoIdentificacion', node)
        if value is not None and 'NoIdentificacion' not in already_processed:
            already_processed.add('NoIdentificacion')
            self.NoIdentificacion = value
        value = find_attr_value_('Cantidad', node)
        if value is not None and 'Cantidad' not in already_processed:
            already_processed.add('Cantidad')
            value = self.gds_parse_decimal(value, node, 'Cantidad')
            self.Cantidad = value
        value = find_attr_value_('Unidad', node)
        if value is not None and 'Unidad' not in already_processed:
            already_processed.add('Unidad')
            self.Unidad = value
        value = find_attr_value_('Descripcion', node)
        if value is not None and 'Descripcion' not in already_processed:
            already_processed.add('Descripcion')
            self.Descripcion = value
        value = find_attr_value_('ValorUnitario', node)
        if value is not None and 'ValorUnitario' not in already_processed:
            already_processed.add('ValorUnitario')
            value = self.gds_parse_decimal(value, node, 'ValorUnitario')
            self.ValorUnitario = value
            self.validate_t_Importe(self.ValorUnitario)    # validate type t_Importe
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            value = self.gds_parse_decimal(value, node, 'Importe')
            self.Importe = value
            self.validate_t_Importe(self.Importe)    # validate type t_Importe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'InformacionAduanera':
            obj_ = InformacionAduaneraType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InformacionAduanera.append(obj_)
            obj_.original_tagname_ = 'InformacionAduanera'
# end class ParteType


class InformacionAduaneraType1(GeneratedsSuper):
    """Nodo opcional para introducir la información aduanera aplicable cuando
    se trate de ventas de primera mano de mercancías importadas o se trate
    de operaciones de comercio exterior con bienes o servicios.Atributo
    requerido para expresar el número del pedimento que ampara la
    importación del bien que se expresa en el siguiente formato: últimos 2
    dígitos del año de validación seguidos por dos espacios, 2 dígitos de
    la aduana de despacho seguidos por dos espacios, 4 dígitos del número
    de la patente seguidos por dos espacios, 1 dígito que corresponde al
    último dígito del año en curso, salvo que se trate de un pedimento
    consolidado iniciado en el año inmediato anterior o del pedimento
    original de una rectificación, seguido de 6 dígitos de la numeración
    progresiva por aduana."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NumeroPedimento=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NumeroPedimento = _cast(None, NumeroPedimento)
        self.NumeroPedimento_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformacionAduaneraType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformacionAduaneraType1.subclass:
            return InformacionAduaneraType1.subclass(*args_, **kwargs_)
        else:
            return InformacionAduaneraType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NumeroPedimento(self):
        return self.NumeroPedimento
    def set_NumeroPedimento(self, NumeroPedimento):
        self.NumeroPedimento = NumeroPedimento
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InformacionAduaneraType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InformacionAduaneraType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InformacionAduaneraType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InformacionAduaneraType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InformacionAduaneraType1'):
        if self.NumeroPedimento is not None and 'NumeroPedimento' not in already_processed:
            already_processed.add('NumeroPedimento')
            outfile.write(' NumeroPedimento=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumeroPedimento), input_name='NumeroPedimento')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InformacionAduaneraType1', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NumeroPedimento', node)
        if value is not None and 'NumeroPedimento' not in already_processed:
            already_processed.add('NumeroPedimento')
            self.NumeroPedimento = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class InformacionAduaneraType1


class ImpuestosType2(GeneratedsSuper):
    """Nodo condicional para expresar el resumen de los impuestos
    aplicables.Atributo condicional para expresar el total de los impuestos
    retenidos que se desprenden de los conceptos expresados en el
    comprobante fiscal digital por Internet. No se permiten valores
    negativos. Es requerido cuando en los conceptos se registren impuestos
    retenidosAtributo condicional para expresar el total de los impuestos
    trasladados que se desprenden de los conceptos expresados en el
    comprobante fiscal digital por Internet. No se permiten valores
    negativos. Es requerido cuando en los conceptos se registren impuestos
    trasladados."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TotalImpuestosRetenidos=None, TotalImpuestosTrasladados=None, Retenciones=None, Traslados=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TotalImpuestosRetenidos = _cast(float, TotalImpuestosRetenidos)
        self.TotalImpuestosRetenidos_nsprefix_ = None
        self.TotalImpuestosTrasladados = _cast(float, TotalImpuestosTrasladados)
        self.TotalImpuestosTrasladados_nsprefix_ = None
        self.Retenciones = Retenciones
        self.Retenciones_nsprefix_ = None
        self.Traslados = Traslados
        self.Traslados_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImpuestosType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImpuestosType2.subclass:
            return ImpuestosType2.subclass(*args_, **kwargs_)
        else:
            return ImpuestosType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Retenciones(self):
        return self.Retenciones
    def set_Retenciones(self, Retenciones):
        self.Retenciones = Retenciones
    def get_Traslados(self):
        return self.Traslados
    def set_Traslados(self, Traslados):
        self.Traslados = Traslados
    def get_TotalImpuestosRetenidos(self):
        return self.TotalImpuestosRetenidos
    def set_TotalImpuestosRetenidos(self, TotalImpuestosRetenidos):
        self.TotalImpuestosRetenidos = TotalImpuestosRetenidos
    def get_TotalImpuestosTrasladados(self):
        return self.TotalImpuestosTrasladados
    def set_TotalImpuestosTrasladados(self, TotalImpuestosTrasladados):
        self.TotalImpuestosTrasladados = TotalImpuestosTrasladados
    def validate_t_Importe(self, value):
        # Validate type t_Importe, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_Importe' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_t_Importe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_t_Importe_patterns_, ))
    validate_t_Importe_patterns_ = [[u'^([0-9]{1,18}(.[0-9]{1,6})?)$']]
    def hasContent_(self):
        if (
            self.Retenciones is not None or
            self.Traslados is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImpuestosType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImpuestosType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImpuestosType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ImpuestosType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ImpuestosType2'):
        if self.TotalImpuestosRetenidos is not None and 'TotalImpuestosRetenidos' not in already_processed:
            already_processed.add('TotalImpuestosRetenidos')
            outfile.write(' TotalImpuestosRetenidos="%s"' % self.gds_format_decimal(self.TotalImpuestosRetenidos, input_name='TotalImpuestosRetenidos'))
        if self.TotalImpuestosTrasladados is not None and 'TotalImpuestosTrasladados' not in already_processed:
            already_processed.add('TotalImpuestosTrasladados')
            outfile.write(' TotalImpuestosTrasladados="%s"' % self.gds_format_decimal(self.TotalImpuestosTrasladados, input_name='TotalImpuestosTrasladados'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImpuestosType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Retenciones is not None:
            namespaceprefix_ = self.Retenciones_nsprefix_ + ':' if (UseCapturedNS_ and self.Retenciones_nsprefix_) else ''
            self.Retenciones.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Retenciones', pretty_print=pretty_print)
        if self.Traslados is not None:
            namespaceprefix_ = self.Traslados_nsprefix_ + ':' if (UseCapturedNS_ and self.Traslados_nsprefix_) else ''
            self.Traslados.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Traslados', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TotalImpuestosRetenidos', node)
        if value is not None and 'TotalImpuestosRetenidos' not in already_processed:
            already_processed.add('TotalImpuestosRetenidos')
            value = self.gds_parse_decimal(value, node, 'TotalImpuestosRetenidos')
            self.TotalImpuestosRetenidos = value
            self.validate_t_Importe(self.TotalImpuestosRetenidos)    # validate type t_Importe
        value = find_attr_value_('TotalImpuestosTrasladados', node)
        if value is not None and 'TotalImpuestosTrasladados' not in already_processed:
            already_processed.add('TotalImpuestosTrasladados')
            value = self.gds_parse_decimal(value, node, 'TotalImpuestosTrasladados')
            self.TotalImpuestosTrasladados = value
            self.validate_t_Importe(self.TotalImpuestosTrasladados)    # validate type t_Importe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Retenciones':
            obj_ = RetencionesType3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Retenciones = obj_
            obj_.original_tagname_ = 'Retenciones'
        elif nodeName_ == 'Traslados':
            obj_ = TrasladosType5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Traslados = obj_
            obj_.original_tagname_ = 'Traslados'
# end class ImpuestosType2


class RetencionesType3(GeneratedsSuper):
    """Nodo condicional para capturar los impuestos retenidos aplicables. Es
    requerido cuando en los conceptos se registre algún impuesto
    retenido."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Retencion=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Retencion is None:
            self.Retencion = []
        else:
            self.Retencion = Retencion
        self.Retencion_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetencionesType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetencionesType3.subclass:
            return RetencionesType3.subclass(*args_, **kwargs_)
        else:
            return RetencionesType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Retencion(self):
        return self.Retencion
    def set_Retencion(self, Retencion):
        self.Retencion = Retencion
    def add_Retencion(self, value):
        self.Retencion.append(value)
    def insert_Retencion_at(self, index, value):
        self.Retencion.insert(index, value)
    def replace_Retencion_at(self, index, value):
        self.Retencion[index] = value
    def hasContent_(self):
        if (
            self.Retencion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RetencionesType3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RetencionesType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RetencionesType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RetencionesType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RetencionesType3'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RetencionesType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Retencion_ in self.Retencion:
            namespaceprefix_ = self.Retencion_nsprefix_ + ':' if (UseCapturedNS_ and self.Retencion_nsprefix_) else ''
            Retencion_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Retencion', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Retencion':
            obj_ = RetencionType4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Retencion.append(obj_)
            obj_.original_tagname_ = 'Retencion'
# end class RetencionesType3


class RetencionType4(GeneratedsSuper):
    """Nodo requerido para la información detallada de una retención de
    impuesto específico.Atributo requerido para señalar la clave del tipo
    de impuesto retenidoAtributo requerido para señalar monto del impuesto
    retenido. No se permiten valores negativos."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Impuesto=None, Importe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Impuesto = _cast(None, Impuesto)
        self.Impuesto_nsprefix_ = None
        self.Importe = _cast(float, Importe)
        self.Importe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetencionType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetencionType4.subclass:
            return RetencionType4.subclass(*args_, **kwargs_)
        else:
            return RetencionType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Impuesto(self):
        return self.Impuesto
    def set_Impuesto(self, Impuesto):
        self.Impuesto = Impuesto
    def get_Importe(self):
        return self.Importe
    def set_Importe(self, Importe):
        self.Importe = Importe
    def validate_c_Impuesto(self, value):
        # Validate type c_Impuesto, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_Impuesto' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_Impuesto' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_Impuesto_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_Impuesto_patterns_, ))
    validate_c_Impuesto_patterns_ = [[u'^([0-9]{3})$']]
    def validate_t_Importe(self, value):
        # Validate type t_Importe, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_Importe' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_t_Importe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_t_Importe_patterns_, ))
    validate_t_Importe_patterns_ = [[u'^([0-9]{1,18}(.[0-9]{1,6})?)$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RetencionType4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RetencionType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RetencionType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RetencionType4', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RetencionType4'):
        if self.Impuesto is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            outfile.write(' Impuesto=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Impuesto), input_name='Impuesto')), ))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe="%s"' % self.gds_format_decimal(self.Importe, input_name='Importe'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RetencionType4', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Impuesto', node)
        if value is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            self.Impuesto = value
            self.validate_c_Impuesto(self.Impuesto)    # validate type c_Impuesto
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            value = self.gds_parse_decimal(value, node, 'Importe')
            self.Importe = value
            self.validate_t_Importe(self.Importe)    # validate type t_Importe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RetencionType4


class TrasladosType5(GeneratedsSuper):
    """Nodo condicional para capturar los impuestos trasladados aplicables. Es
    requerido cuando en los conceptos se registre un impuesto
    trasladado."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Traslado=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Traslado is None:
            self.Traslado = []
        else:
            self.Traslado = Traslado
        self.Traslado_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrasladosType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrasladosType5.subclass:
            return TrasladosType5.subclass(*args_, **kwargs_)
        else:
            return TrasladosType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Traslado(self):
        return self.Traslado
    def set_Traslado(self, Traslado):
        self.Traslado = Traslado
    def add_Traslado(self, value):
        self.Traslado.append(value)
    def insert_Traslado_at(self, index, value):
        self.Traslado.insert(index, value)
    def replace_Traslado_at(self, index, value):
        self.Traslado[index] = value
    def hasContent_(self):
        if (
            self.Traslado
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TrasladosType5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrasladosType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrasladosType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TrasladosType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TrasladosType5'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TrasladosType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Traslado_ in self.Traslado:
            namespaceprefix_ = self.Traslado_nsprefix_ + ':' if (UseCapturedNS_ and self.Traslado_nsprefix_) else ''
            Traslado_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Traslado', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Traslado':
            obj_ = TrasladoType6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Traslado.append(obj_)
            obj_.original_tagname_ = 'Traslado'
# end class TrasladosType5


class TrasladoType6(GeneratedsSuper):
    """Nodo requerido para la información detallada de un traslado de impuesto
    específico.Atributo requerido para señalar la clave del tipo de
    impuesto trasladado.Atributo requerido para señalar la clave del tipo
    de factor que se aplica a la base del impuesto.Atributo requerido para
    señalar el valor de la tasa o cuota del impuesto que se traslada por
    los conceptos amparados en el comprobante.Atributo requerido para
    señalar la suma del importe del impuesto trasladado, agrupado por
    impuesto, TipoFactor y TasaOCuota. No se permiten valores negativos."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Impuesto=None, TipoFactor=None, TasaOCuota=None, Importe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Impuesto = _cast(None, Impuesto)
        self.Impuesto_nsprefix_ = None
        self.TipoFactor = _cast(None, TipoFactor)
        self.TipoFactor_nsprefix_ = None
        self.TasaOCuota = _cast(float, TasaOCuota)
        self.TasaOCuota_nsprefix_ = None
        self.Importe = _cast(float, Importe)
        self.Importe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrasladoType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrasladoType6.subclass:
            return TrasladoType6.subclass(*args_, **kwargs_)
        else:
            return TrasladoType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Impuesto(self):
        return self.Impuesto
    def set_Impuesto(self, Impuesto):
        self.Impuesto = Impuesto
    def get_TipoFactor(self):
        return self.TipoFactor
    def set_TipoFactor(self, TipoFactor):
        self.TipoFactor = TipoFactor
    def get_TasaOCuota(self):
        return self.TasaOCuota
    def set_TasaOCuota(self, TasaOCuota):
        self.TasaOCuota = TasaOCuota
    def get_Importe(self):
        return self.Importe
    def set_Importe(self, Importe):
        self.Importe = Importe
    def validate_c_Impuesto(self, value):
        # Validate type c_Impuesto, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on c_Impuesto' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on c_Impuesto' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_c_Impuesto_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_c_Impuesto_patterns_, ))
    validate_c_Impuesto_patterns_ = [[u'^([0-9]{3})$']]
    def validate_c_TipoFactor(self, value):
        # Validate type c_TipoFactor, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Tasa', 'Cuota', 'Exento']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on c_TipoFactor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_c_TasaOCuota(self, value):
        # Validate type c_TasaOCuota, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on c_TasaOCuota' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 7:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on c_TasaOCuota' % {"value": value, "lineno": lineno} )
                result = False
    def validate_t_Importe(self, value):
        # Validate type t_Importe, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.000000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on t_Importe' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_t_Importe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_t_Importe_patterns_, ))
    validate_t_Importe_patterns_ = [[u'^([0-9]{1,18}(.[0-9]{1,6})?)$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TrasladoType6', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrasladoType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrasladoType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TrasladoType6', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TrasladoType6'):
        if self.Impuesto is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            outfile.write(' Impuesto=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Impuesto), input_name='Impuesto')), ))
        if self.TipoFactor is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            outfile.write(' TipoFactor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TipoFactor), input_name='TipoFactor')), ))
        if self.TasaOCuota is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            outfile.write(' TasaOCuota="%s"' % self.gds_format_decimal(self.TasaOCuota, input_name='TasaOCuota'))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe="%s"' % self.gds_format_decimal(self.Importe, input_name='Importe'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TrasladoType6', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Impuesto', node)
        if value is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            self.Impuesto = value
            self.validate_c_Impuesto(self.Impuesto)    # validate type c_Impuesto
        value = find_attr_value_('TipoFactor', node)
        if value is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            self.TipoFactor = value
            self.validate_c_TipoFactor(self.TipoFactor)    # validate type c_TipoFactor
        value = find_attr_value_('TasaOCuota', node)
        if value is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            value = self.gds_parse_decimal(value, node, 'TasaOCuota')
            self.TasaOCuota = value
            self.validate_c_TasaOCuota(self.TasaOCuota)    # validate type c_TasaOCuota
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            value = self.gds_parse_decimal(value, node, 'Importe')
            self.Importe = value
            self.validate_t_Importe(self.Importe)    # validate type t_Importe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TrasladoType6


class ComplementoType(GeneratedsSuper):
    """Nodo opcional donde se incluyen los nodos complementarios determinados
    por el SAT, de acuerdo con las disposiciones particulares para un
    sector o actividad específica."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComplementoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComplementoType.subclass:
            return ComplementoType.subclass(*args_, **kwargs_)
        else:
            return ComplementoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComplementoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComplementoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComplementoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ComplementoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ComplementoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComplementoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'ComplementoType')
        self.add_anytypeobjs_(content_)
# end class ComplementoType


class AddendaType(GeneratedsSuper):
    """Nodo opcional para recibir las extensiones al presente formato que sean
    de utilidad al contribuyente. Para las reglas de uso del mismo,
    referirse al formato origen."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddendaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddendaType.subclass:
            return AddendaType.subclass(*args_, **kwargs_)
        else:
            return AddendaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AddendaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddendaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddendaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AddendaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AddendaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AddendaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'AddendaType')
        self.add_anytypeobjs_(content_)
# end class AddendaType


class TransaccionType(GeneratedsSuper):
    """Nodo opcional para identificar la transaccion asociada a la
    petición.Identificador de la transaccion."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransaccionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransaccionType.subclass:
            return TransaccionType.subclass(*args_, **kwargs_)
        else:
            return TransaccionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TransaccionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransaccionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransaccionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransaccionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TransaccionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TransaccionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TransaccionType


class TipoComprobanteType(GeneratedsSuper):
    """Clave del tipo de comprobanteNombre del tipo de comprobante"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, clave=None, nombre=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.clave = _cast(None, clave)
        self.clave_nsprefix_ = None
        self.nombre = _cast(None, nombre)
        self.nombre_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TipoComprobanteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TipoComprobanteType.subclass:
            return TipoComprobanteType.subclass(*args_, **kwargs_)
        else:
            return TipoComprobanteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_clave(self):
        return self.clave
    def set_clave(self, clave):
        self.clave = clave
    def get_nombre(self):
        return self.nombre
    def set_nombre(self, nombre):
        self.nombre = nombre
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TipoComprobanteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TipoComprobanteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TipoComprobanteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TipoComprobanteType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TipoComprobanteType'):
        if self.clave is not None and 'clave' not in already_processed:
            already_processed.add('clave')
            outfile.write(' clave=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clave), input_name='clave')), ))
        if self.nombre is not None and 'nombre' not in already_processed:
            already_processed.add('nombre')
            outfile.write(' nombre=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nombre), input_name='nombre')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TipoComprobanteType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clave', node)
        if value is not None and 'clave' not in already_processed:
            already_processed.add('clave')
            self.clave = value
        value = find_attr_value_('nombre', node)
        if value is not None and 'nombre' not in already_processed:
            already_processed.add('nombre')
            self.nombre = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TipoComprobanteType


class SucursalType(GeneratedsSuper):
    """Atributo opcional del identificador de la sucursal que emite el
    comprobante fiscal.Atributo requerido del nombre de la sucursal que
    emite el comprobante fiscal."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, nombre=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.nombre = _cast(None, nombre)
        self.nombre_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SucursalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SucursalType.subclass:
            return SucursalType.subclass(*args_, **kwargs_)
        else:
            return SucursalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_nombre(self):
        return self.nombre
    def set_nombre(self, nombre):
        self.nombre = nombre
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SucursalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SucursalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SucursalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SucursalType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SucursalType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.nombre is not None and 'nombre' not in already_processed:
            already_processed.add('nombre')
            outfile.write(' nombre=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nombre), input_name='nombre')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SucursalType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('nombre', node)
        if value is not None and 'nombre' not in already_processed:
            already_processed.add('nombre')
            self.nombre = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SucursalType


class ReceptorType7(GeneratedsSuper):
    """Correo electrónico del ReceptorAtributo opcional del codigo del
    receptor."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, emailReceptor=None, codigoReceptor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.emailReceptor = _cast(None, emailReceptor)
        self.emailReceptor_nsprefix_ = None
        self.codigoReceptor = _cast(None, codigoReceptor)
        self.codigoReceptor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReceptorType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReceptorType7.subclass:
            return ReceptorType7.subclass(*args_, **kwargs_)
        else:
            return ReceptorType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_emailReceptor(self):
        return self.emailReceptor
    def set_emailReceptor(self, emailReceptor):
        self.emailReceptor = emailReceptor
    def get_codigoReceptor(self):
        return self.codigoReceptor
    def set_codigoReceptor(self, codigoReceptor):
        self.codigoReceptor = codigoReceptor
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReceptorType7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReceptorType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReceptorType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReceptorType7', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReceptorType7'):
        if self.emailReceptor is not None and 'emailReceptor' not in already_processed:
            already_processed.add('emailReceptor')
            outfile.write(' emailReceptor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.emailReceptor), input_name='emailReceptor')), ))
        if self.codigoReceptor is not None and 'codigoReceptor' not in already_processed:
            already_processed.add('codigoReceptor')
            outfile.write(' codigoReceptor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codigoReceptor), input_name='codigoReceptor')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReceptorType7', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('emailReceptor', node)
        if value is not None and 'emailReceptor' not in already_processed:
            already_processed.add('emailReceptor')
            self.emailReceptor = value
        value = find_attr_value_('codigoReceptor', node)
        if value is not None and 'codigoReceptor' not in already_processed:
            already_processed.add('codigoReceptor')
            self.codigoReceptor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ReceptorType7


class MetadatosType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Metadato=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Metadato is None:
            self.Metadato = []
        else:
            self.Metadato = Metadato
        self.Metadato_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetadatosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetadatosType.subclass:
            return MetadatosType.subclass(*args_, **kwargs_)
        else:
            return MetadatosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Metadato(self):
        return self.Metadato
    def set_Metadato(self, Metadato):
        self.Metadato = Metadato
    def add_Metadato(self, value):
        self.Metadato.append(value)
    def insert_Metadato_at(self, index, value):
        self.Metadato.insert(index, value)
    def replace_Metadato_at(self, index, value):
        self.Metadato[index] = value
    def hasContent_(self):
        if (
            self.Metadato
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MetadatosType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MetadatosType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MetadatosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MetadatosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MetadatosType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MetadatosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Metadato_ in self.Metadato:
            namespaceprefix_ = self.Metadato_nsprefix_ + ':' if (UseCapturedNS_ and self.Metadato_nsprefix_) else ''
            Metadato_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Metadato', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Metadato':
            obj_ = MetadatoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Metadato.append(obj_)
            obj_.original_tagname_ = 'Metadato'
# end class MetadatosType


class MetadatoType(GeneratedsSuper):
    """Clave del metadatoValor del metadato"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, clave=None, valor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.clave = _cast(None, clave)
        self.clave_nsprefix_ = None
        self.valor = _cast(None, valor)
        self.valor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetadatoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetadatoType.subclass:
            return MetadatoType.subclass(*args_, **kwargs_)
        else:
            return MetadatoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_clave(self):
        return self.clave
    def set_clave(self, clave):
        self.clave = clave
    def get_valor(self):
        return self.valor
    def set_valor(self, valor):
        self.valor = valor
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MetadatoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MetadatoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MetadatoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MetadatoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MetadatoType'):
        if self.clave is not None and 'clave' not in already_processed:
            already_processed.add('clave')
            outfile.write(' clave=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clave), input_name='clave')), ))
        if self.valor is not None and 'valor' not in already_processed:
            already_processed.add('valor')
            outfile.write(' valor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valor), input_name='valor')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MetadatoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clave', node)
        if value is not None and 'clave' not in already_processed:
            already_processed.add('clave')
            self.clave = value
        value = find_attr_value_('valor', node)
        if value is not None and 'valor' not in already_processed:
            already_processed.add('valor')
            self.valor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class MetadatoType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'RequestCFD'
        rootClass = RequestCFD
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'RequestCFD'
        rootClass = RequestCFD
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'RequestCFD'
        rootClass = RequestCFD
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'RequestCFD'
        rootClass = RequestCFD
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from RequestCFD_v33 import *\n\n')
        sys.stdout.write('import RequestCFD_v33 as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

__all__ = [
    "AddendaType",
    "CfdiInternoRelacionadoType",
    "CfdiRelacionadoType",
    "CfdiRelacionadosType",
    "ComplementoConceptoType",
    "ComplementoType",
    "ComprobanteType",
    "ConceptoType",
    "ConceptosType",
    "CuentaPredialType",
    "EmisorType",
    "ImpuestosType",
    "ImpuestosType2",
    "InformacionAduaneraType",
    "InformacionAduaneraType1",
    "MetadatoType",
    "MetadatosType",
    "ParteType",
    "ReceptorType",
    "ReceptorType7",
    "RequestCFD",
    "RetencionType",
    "RetencionType4",
    "RetencionesType",
    "RetencionesType3",
    "SucursalType",
    "TipoComprobanteType",
    "TransaccionType",
    "TrasladoType",
    "TrasladoType6",
    "TrasladosType",
    "TrasladosType5"
]
